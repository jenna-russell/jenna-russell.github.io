{"version":3,"sources":["../src/types.ts","../src/cache.ts","../src/version.ts","../src/client.ts","../src/config.ts","../src/logging.ts","../src/canonical.ts"],"sourcesContent":["// typescript/src/types.ts\nexport type Json = { [key: string]: Json } | Json[] | string | number | boolean | null;\n\nexport interface ObjectMeta {\n  objectId: string;\n  label: string;\n  issueNumber: number;  // Added field to track GitHub issue number\n  createdAt: Date;\n  updatedAt: Date;\n  version: number;\n}\n\nexport interface StoredObject {\n  meta: ObjectMeta;\n  data: Json;\n}\n\nexport interface GitHubStoreConfig {\n  baseLabel?: string;\n  uidPrefix?: string;\n  reactions?: {\n    processed?: string;\n    initialState?: string;\n  };\n}\n\nexport interface CommentMeta {\n  client_version: string;\n  timestamp: string;\n  update_mode: string;\n  issue_number: number;  // Added field to track GitHub issue number\n}\n\nexport interface CommentPayload {\n  _data: Json;\n  _meta: CommentMeta;\n  type?: string;\n}\n\n/* Constants */\n\nexport enum LabelNames {\n  GH_STORE = \"gh-store\",\n  STORED_OBJECT = \"stored-object\",\n  DEPRECATED = \"deprecated-object\",\n  UID_PREFIX = \"UID:\",\n  ALIAS_TO_PREFIX = \"ALIAS-TO:\"\n}\n","// src/cache.ts\nexport interface CacheEntry {\n  issueNumber: number;\n  lastAccessed: number; // Using timestamp instead of Date for easier comparison\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CacheConfig {\n  maxSize?: number;\n  ttl?: number; // Time-to-live in milliseconds\n}\n\nexport class IssueCache {\n  private cache: Map<string, CacheEntry>;\n  private maxSize: number;\n  private ttl: number;\n  private accessOrder: string[]; // Track order of access\n\n  constructor(config: CacheConfig = {}) {\n    this.cache = new Map();\n    this.maxSize = config.maxSize ?? 1000;\n    this.ttl = config.ttl ?? 1000 * 60 * 60; // Default 1 hour TTL\n    this.accessOrder = [];\n  }\n\n  get(objectId: string): number | undefined {\n    const entry = this.cache.get(objectId);\n    \n    if (!entry) {\n      return undefined;\n    }\n\n    // Check if entry has expired\n    if (Date.now() - entry.lastAccessed > this.ttl) {\n      this.cache.delete(objectId);\n      this.removeFromAccessOrder(objectId);\n      return undefined;\n    }\n\n    // Update last accessed time and move to front of access order\n    entry.lastAccessed = Date.now();\n    this.updateAccessOrder(objectId);\n    return entry.issueNumber;\n  }\n\n  set(objectId: string, issueNumber: number, metadata: { createdAt: Date; updatedAt: Date }): void {\n    // Evict least recently used entry if cache is full\n    if (this.cache.size >= this.maxSize && !this.cache.has(objectId)) {\n      const lru = this.accessOrder[this.accessOrder.length - 1];\n      if (lru) {\n        this.cache.delete(lru);\n        this.removeFromAccessOrder(lru);\n      }\n    }\n\n    // Add/update entry\n    this.cache.set(objectId, {\n      issueNumber,\n      lastAccessed: Date.now(),\n      createdAt: metadata.createdAt,\n      updatedAt: metadata.updatedAt\n    });\n\n    this.updateAccessOrder(objectId);\n  }\n\n  remove(objectId: string): void {\n    this.cache.delete(objectId);\n    this.removeFromAccessOrder(objectId);\n  }\n\n  clear(): void {\n    this.cache.clear();\n    this.accessOrder = [];\n  }\n\n  getStats(): { size: number; maxSize: number; ttl: number } {\n    return {\n      size: this.cache.size,\n      maxSize: this.maxSize,\n      ttl: this.ttl\n    };\n  }\n\n  shouldRefresh(objectId: string, latestUpdate: Date): boolean {\n    const entry = this.cache.get(objectId);\n    if (!entry) return true;\n\n    return latestUpdate > entry.updatedAt;\n  }\n\n  private updateAccessOrder(objectId: string): void {\n    this.removeFromAccessOrder(objectId);\n    this.accessOrder.unshift(objectId); // Add to front\n  }\n\n  private removeFromAccessOrder(objectId: string): void {\n    const index = this.accessOrder.indexOf(objectId);\n    if (index > -1) {\n      this.accessOrder.splice(index, 1);\n    }\n  }\n}\n","// typescript/src/version.ts\n// Version is updated by build process\nexport const CLIENT_VERSION = '0.11.1';\n","// typescript/src/client.ts\nimport { \n  CommentPayload, \n  ObjectMeta, \n  GitHubStoreConfig, \n  Json, \n  LabelNames, \n  StoredObject \n} from './types';\nimport { IssueCache, CacheConfig } from './cache';\nimport { CLIENT_VERSION } from './version';\n\ninterface GitHubIssue {\n  number: number;\n  body: string;\n  created_at: string;\n  updated_at: string;\n  labels: Array<{ name: string }>;\n  state?: string;\n}\n\nexport class GitHubStoreClient {\n  private token: string | null;\n  private repo: string;\n  private config: Required<GitHubStoreConfig>;\n  private cache: IssueCache;\n\n  constructor(\n    token: string | null, \n    repo: string,\n    config: GitHubStoreConfig & { cache?: CacheConfig } = {}\n  ) {\n    this.token = token;\n    this.repo = repo;\n    \n    if (!this.repo) {\n      throw new Error('Repository is required');\n    }\n\n    this.config = {\n      baseLabel: config.baseLabel ?? \"stored-object\",\n      uidPrefix: config.uidPrefix ?? \"UID:\",\n      reactions: {\n        processed: config.reactions?.processed ?? \"+1\",\n        initialState: config.reactions?.initialState ?? \"rocket\",\n      },\n    };\n    this.cache = new IssueCache(config.cache);\n  }\n  \n  /**\n   * Check if the client is operating in public (unauthenticated) mode\n   * @returns True if client is using unauthenticated mode\n   */\n  public isPublic(): boolean {\n    return this.token === null;\n  }\n\n  /**\n   * Makes a request to the GitHub API\n   * \n   * @param path - The API path to request (e.g., \"/issues\")\n   * @param options - Request options including optional params\n   * @returns The JSON response from the API\n   */\n  public async fetchFromGitHub<T>(path: string, options: RequestInit & { params?: Record<string, string> } = {}): Promise<T> {\n    const url = new URL(`https://api.github.com/repos/${this.repo}${path}`);\n    \n    if (options.params) {\n      Object.entries(options.params).forEach(([key, value]) => {\n        url.searchParams.append(key, value);\n      });\n      delete options.params;\n    }\n  \n    // Create a new headers object\n    const headersObj: Record<string, string> = {\n      \"Accept\": \"application/vnd.github.v3+json\"\n    };\n    \n    // Add any existing headers from options\n    if (options.headers) {\n      const existingHeaders = options.headers as Record<string, string>;\n      Object.keys(existingHeaders).forEach(key => {\n        headersObj[key] = existingHeaders[key];\n      });\n    }\n    \n    // Add authorization header only if token is provided\n    if (this.token) {\n      headersObj[\"Authorization\"] = `token ${this.token}`;\n    }\n  \n    const response = await fetch(url.toString(), {\n      ...options,\n      headers: headersObj\n    });\n  \n    if (!response.ok) {\n      throw new Error(`GitHub API error: ${response.status}`);\n    }\n  \n    return response.json() as Promise<T>;\n  }\n\n  private createCommentPayload(data: Json, issueNumber: number, type?: string): CommentPayload {\n    const payload: CommentPayload = {\n      _data: data,\n      _meta: {\n        client_version: CLIENT_VERSION,\n        timestamp: new Date().toISOString(),\n        update_mode: \"append\",\n        issue_number: issueNumber  // Include issue number in metadata\n      }\n    };\n    \n    if (type) {\n      payload.type = type;\n    }\n    \n    return payload;\n  }\n\n  async getObject(objectId: string): Promise<StoredObject> {\n    // Try to get issue number from cache\n    const cachedIssueNumber = this.cache.get(objectId);\n    let issue: GitHubIssue | undefined;\n\n    if (cachedIssueNumber) {\n      // Try to fetch directly using cached issue number\n      try {\n        issue = await this.fetchFromGitHub<GitHubIssue>(`/issues/${cachedIssueNumber}`);\n\n        // Verify it's the correct issue\n        if (!this._verifyIssueLabels(issue, objectId)) {\n          this.cache.remove(objectId);\n          issue = undefined;\n        }\n      } catch (error) {\n        // If issue not found, remove from cache\n        this.cache.remove(objectId);\n      }\n    }\n\n    if (!issue) {\n      // Fall back to searching by labels\n      const issues = await this.fetchFromGitHub<GitHubIssue[]>(\"/issues\", {\n        method: \"GET\",\n        params: {\n          labels: [LabelNames.GH_STORE, this.config.baseLabel, `${this.config.uidPrefix}${objectId}`].join(\",\"),\n          state: \"closed\",\n        },\n      });\n\n      if (!issues || issues.length === 0) {\n        throw new Error(`No object found with ID: ${objectId}`);\n      }\n\n      issue = issues[0];\n    }\n\n    if (!issue?.body) {\n      throw new Error(`Invalid issue data received for ID: ${objectId}`);\n    }\n\n    const data = JSON.parse(issue.body) as Json;\n    const createdAt = new Date(issue.created_at);\n    const updatedAt = new Date(issue.updated_at);\n\n    // Update cache\n    this.cache.set(objectId, issue.number, { createdAt, updatedAt });\n\n    const meta: ObjectMeta = {\n      objectId,\n      label: `${this.config.uidPrefix}${objectId}`,\n      issueNumber: issue.number,\n      createdAt,\n      updatedAt,\n      version: await this._getVersion(issue.number)\n    };\n\n    return { meta, data };\n  }\n\n  async createObject(objectId: string, data: Json, extraLabels: string[] = []): Promise<StoredObject> {\n    if (!this.token) {\n      throw new Error('Authentication required for creating objects');\n    }\n\n    const uidLabel = `${this.config.uidPrefix}${objectId}`;\n    \n    // Combine required labels with any custom labels\n    const labels = [LabelNames.GH_STORE, this.config.baseLabel, uidLabel, ...extraLabels];\n    \n    const issue = await this.fetchFromGitHub<{\n      number: number;\n      created_at: string;\n      updated_at: string;\n      html_url: string;\n    }>(\"/issues\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        title: `Stored Object: ${objectId}`,\n        body: JSON.stringify(data, null, 2),\n        labels: labels\n      })\n    });\n\n    // Add to cache immediately\n    this.cache.set(objectId, issue.number, {\n      createdAt: new Date(issue.created_at),\n      updatedAt: new Date(issue.updated_at)\n    });\n\n    // Create and add initial state comment\n    const initialState = this.createCommentPayload(data, issue.number, \"initial_state\");\n    \n    const comment = await this.fetchFromGitHub<{ id: number }>(`/issues/${issue.number}/comments`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        body: JSON.stringify(initialState, null, 2)\n      })\n    });\n\n    await this.fetchFromGitHub(`/issues/comments/${comment.id}/reactions`, {\n      method: \"POST\",\n      body: JSON.stringify({ content: this.config.reactions.processed })\n    });\n\n    await this.fetchFromGitHub(`/issues/comments/${comment.id}/reactions`, {\n      method: \"POST\",\n      body: JSON.stringify({ content: this.config.reactions.initialState })\n    });\n\n    await this.fetchFromGitHub(`/issues/${issue.number}`, {\n      method: \"PATCH\",\n      body: JSON.stringify({ state: \"closed\" })\n    });\n\n    const meta: ObjectMeta = {\n      objectId,\n      label: uidLabel,\n      issueNumber: issue.number,\n      createdAt: new Date(issue.created_at),\n      updatedAt: new Date(issue.updated_at),\n      version: 1\n    };\n\n    return { meta, data };\n  }\n  \n  private _verifyIssueLabels(issue: { labels: Array<{ name: string }> }, objectId: string): boolean {\n    const expectedLabels = new Set([\n      this.config.baseLabel,\n      `${this.config.uidPrefix}${objectId}`\n    ]);\n\n    return issue.labels.some(label => expectedLabels.has(label.name));\n  }\n  \n  async updateObject(objectId: string, changes: Json): Promise<StoredObject> {\n    if (!this.token) {\n      throw new Error('Authentication required for updating objects');\n    }\n\n    // Get the object's issue first\n    const issues = await this.fetchFromGitHub<Array<{\n      number: number;\n      state: string;\n    }>>(\"/issues\", {\n      method: \"GET\",\n      params: {\n        labels: [this.config.baseLabel, `${this.config.uidPrefix}${objectId}`].join(\",\"),\n        state: \"all\",\n      },\n    });\n\n    if (!issues || issues.length === 0) {\n      throw new Error(`No object found with ID: ${objectId}`);\n    }\n\n    const issue = issues[0];\n    \n    // Create update payload with metadata\n    const updatePayload = this.createCommentPayload(changes, issue.number);\n\n    // Add update comment\n    await this.fetchFromGitHub(`/issues/${issue.number}/comments`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        body: JSON.stringify(updatePayload, null, 2)\n      })\n    });\n\n    // Reopen issue to trigger processing\n    await this.fetchFromGitHub(`/issues/${issue.number}`, {\n      method: \"PATCH\",\n      body: JSON.stringify({ state: \"open\" })\n    });\n\n    // Return current state (before update is processed)\n    return this.getObject(objectId);\n  }\n\n  // Rest of methods remain the same...\n  \n  async listAll(): Promise<Record<string, StoredObject>> {\n    const issues = await this.fetchFromGitHub<Array<{\n      number: number;\n      body: string;\n      created_at: string;\n      updated_at: string;\n      labels: Array<{ name: string }>;\n    }>>(\"/issues\", {\n      method: \"GET\",\n      params: {\n        labels: this.config.baseLabel,\n        state: \"closed\",\n      },\n    });\n\n    const objects: Record<string, StoredObject> = {};\n\n    for (const issue of issues) {\n      // Skip archived objects\n      if (issue.labels.some((label) => label.name === \"archived\")) {\n        continue;\n      }\n\n      try {\n        const objectId = this._getObjectIdFromLabels(issue);\n        const data = JSON.parse(issue.body) as Json;\n\n        const meta: ObjectMeta = {\n          objectId,\n          label: objectId,\n          issueNumber: issue.number,\n          createdAt: new Date(issue.created_at),\n          updatedAt: new Date(issue.updated_at),\n          version: await this._getVersion(issue.number) // shuold this just be issue._meta.version or something ilke that?\n        };\n\n        objects[objectId] = { meta, data };\n      } catch (error) {\n        // Skip issues that can't be processed\n        continue;\n      }\n    }\n\n    return objects;\n  }\n\n  async listUpdatedSince(timestamp: Date): Promise<Record<string, StoredObject>> {\n    const issues = await this.fetchFromGitHub<Array<{\n      number: number;\n      body: string;\n      created_at: string;\n      updated_at: string;\n      labels: Array<{ name: string }>;\n    }>>(\"/issues\", {\n      method: \"GET\",\n      params: {\n        labels: this.config.baseLabel,\n        state: \"closed\",\n        since: timestamp.toISOString(),\n      },\n    });\n\n    const objects: Record<string, StoredObject> = {};\n\n    for (const issue of issues) {\n      if (issue.labels.some((label) => label.name === \"archived\")) {\n        continue;\n      }\n\n      try {\n        const objectId = this._getObjectIdFromLabels(issue);\n        const data = JSON.parse(issue.body) as Json;\n        const updatedAt = new Date(issue.updated_at);\n\n        if (updatedAt > timestamp) {\n          const meta: ObjectMeta = {\n            objectId,\n            label: objectId,\n            issueNumber: issue.number,\n            createdAt: new Date(issue.created_at),\n            updatedAt,\n            version: await this._getVersion(issue.number)\n          };\n\n          objects[objectId] = { meta, data };\n        }\n      } catch (error) {\n        // Skip issues that can't be processed\n        continue;\n      }\n    }\n\n    return objects;\n  }\n\n  async getObjectHistory(objectId: string): Promise<Array<{\n    timestamp: string;\n    type: string;\n    data: Json;\n    commentId: number;\n  }>> {\n    const issues = await this.fetchFromGitHub<Array<{\n      number: number;\n      labels: Array<{ name: string }>;\n    }>>(\"/issues\", {\n      method: \"GET\",\n      params: {\n        labels: [this.config.baseLabel, `${this.config.uidPrefix}${objectId}`].join(\",\"),\n        state: \"all\",\n      },\n    });\n\n    if (!issues || issues.length === 0) {\n      throw new Error(`No object found with ID: ${objectId}`);\n    }\n\n    const issue = issues[0];\n    const comments = await this.fetchFromGitHub<Array<{\n      id: number;\n      created_at: string;\n      body: string;\n    }>>(`/issues/${issue.number}/comments`);\n    \n    const history = [];\n\n    for (const comment of comments) {\n      try {\n        const payload = JSON.parse(comment.body);\n        let commentType = 'update';\n        let commentData: Json;\n        let metadata = {\n          client_version: 'legacy',\n          timestamp: comment.created_at,\n          update_mode: 'append'\n        };\n\n        if (typeof payload === 'object') {\n          if ('_data' in payload) {\n            // New format with metadata\n            commentType = payload.type || 'update';\n            commentData = payload._data;\n            metadata = payload._meta || metadata;\n          } else if ('type' in payload && payload.type === 'initial_state') {\n            // Old initial state format\n            commentType = 'initial_state';\n            commentData = payload.data;\n          } else {\n            // Legacy format\n            commentData = payload;\n          }\n        } else {\n          commentData = payload;\n        }\n\n        history.push({\n          timestamp: comment.created_at,\n          type: commentType,\n          data: commentData,\n          commentId: comment.id,\n        });\n      } catch (error) {\n        // Skip comments with invalid JSON\n        continue;\n      }\n    }\n\n    return history;\n  }\n\n  private async _getVersion(issueNumber: number): Promise<number> {\n    const comments = await this.fetchFromGitHub<Array<unknown>>(`/issues/${issueNumber}/comments`);\n    return comments.length + 1;\n  }\n\n  private _getObjectIdFromLabels(issue: { labels: Array<{ name: string }> }): string {\n      for (const label of issue.labels) {\n        if (label.name !== this.config.baseLabel && label.name.startsWith(this.config.uidPrefix)) {\n          return label.name.slice(this.config.uidPrefix.length);\n        }\n      }\n      throw new Error(`No UID label found with prefix ${this.config.uidPrefix}`);\n    }\n}\n","// typescript/src/config.ts\nexport interface StoreConfig {\n  // Base configuration\n  baseLabel: string;\n  uidPrefix: string;\n  \n  // Reaction settings\n  reactions: {\n    processed: string;\n    initialState: string;\n  };\n  \n  // API retry settings\n  retries: {\n    maxAttempts: number;\n    backoffFactor: number;\n  };\n  \n  // Rate limiting\n  rateLimit: {\n    maxRequestsPerHour: number;\n  };\n}\n\nexport const DEFAULT_CONFIG: StoreConfig = {\n  baseLabel: \"stored-object\",\n  uidPrefix: \"UID:\",\n  reactions: {\n    processed: \"+1\",\n    initialState: \"rocket\"\n  },\n  retries: {\n    maxAttempts: 3,\n    backoffFactor: 2\n  },\n  rateLimit: {\n    maxRequestsPerHour: 1000\n  }\n};\n\nexport function mergeConfig(userConfig: Partial<StoreConfig>): StoreConfig {\n  return {\n    ...DEFAULT_CONFIG,\n    ...userConfig,\n    reactions: {\n      ...DEFAULT_CONFIG.reactions,\n      ...userConfig.reactions\n    },\n    retries: {\n      ...DEFAULT_CONFIG.retries,\n      ...userConfig.retries\n    },\n    rateLimit: {\n      ...DEFAULT_CONFIG.rateLimit,\n      ...userConfig.rateLimit\n    }\n  };\n}\n\n// Helper to validate token format\nexport function validateToken(token: string): boolean {\n  // Check if it's a valid GitHub token format\n  return /^gh[ps]_[a-zA-Z0-9]{36}$/.test(token);\n}\n\n// Helper to validate repository format\nexport function validateRepo(repo: string): boolean {\n  return /^[\\w-]+\\/[\\w-]+$/.test(repo);\n}\n\n// Error types for configuration issues\nexport class ConfigError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ConfigError';\n  }\n}\n\nexport class TokenError extends ConfigError {\n  constructor(message = 'Invalid GitHub token format') {\n    super(message);\n    this.name = 'TokenError';\n  }\n}\n\nexport class RepoError extends ConfigError {\n  constructor(message = 'Invalid repository format. Use owner/repo') {\n    super(message);\n    this.name = 'RepoError';\n  }\n}\n","// typescript/src/logging.ts\n/**\n * Simple logger utility that avoids console statements\n * but collects messages for potential later use\n */\n\n// Log levels\nexport enum LogLevel {\n  ERROR = 'error',\n  WARN = 'warn',\n  INFO = 'info',\n  DEBUG = 'debug'\n}\n\n// Logger configuration\nexport interface LoggerConfig {\n  level: LogLevel;\n  silent?: boolean;\n  prefix?: string;\n}\n\n// Log entry structure\nexport interface LogEntry {\n  timestamp: string;\n  level: LogLevel;\n  module: string;\n  message: string;\n  metadata?: Record<string, unknown>;\n}\n\n// Default configuration\nconst DEFAULT_CONFIG: LoggerConfig = {\n  level: LogLevel.INFO,\n  silent: false\n};\n\n// Mapping of log levels to numeric values for comparison\nconst LOG_LEVEL_VALUES: Record<LogLevel, number> = {\n  [LogLevel.ERROR]: 3,\n  [LogLevel.WARN]: 2,\n  [LogLevel.INFO]: 1,\n  [LogLevel.DEBUG]: 0\n};\n\n/**\n * Logger utility class that avoids direct console usage\n */\nexport class Logger {\n  private moduleName: string;\n  private config: LoggerConfig;\n  private entries: LogEntry[] = [];\n\n  /**\n   * Create a new logger\n   * @param moduleName Name of the module using this logger\n   * @param config Optional configuration\n   */\n  constructor(moduleName: string, config: Partial<LoggerConfig> = {}) {\n    this.moduleName = moduleName;\n    this.config = {\n      ...DEFAULT_CONFIG,\n      ...config\n    };\n  }\n\n  /**\n   * Log a debug message\n   * @param message Message content\n   * @param meta Optional metadata\n   */\n  debug(message: string, meta?: Record<string, unknown>): void {\n    this.log(LogLevel.DEBUG, message, meta);\n  }\n\n  /**\n   * Log an info message\n   * @param message Message content\n   * @param meta Optional metadata\n   */\n  info(message: string, meta?: Record<string, unknown>): void {\n    this.log(LogLevel.INFO, message, meta);\n  }\n\n  /**\n   * Log a warning message\n   * @param message Message content\n   * @param meta Optional metadata\n   */\n  warn(message: string, meta?: Record<string, unknown>): void {\n    this.log(LogLevel.WARN, message, meta);\n  }\n\n  /**\n   * Log an error message\n   * @param message Message content\n   * @param meta Optional metadata\n   */\n  error(message: string, meta?: Record<string, unknown>): void {\n    this.log(LogLevel.ERROR, message, meta);\n  }\n\n  /**\n   * Internal helper method to record logs\n   */\n  private log(level: LogLevel, message: string, meta?: Record<string, unknown>): void {\n    // Check if this log level should be processed\n    if (LOG_LEVEL_VALUES[level] < LOG_LEVEL_VALUES[this.config.level]) {\n      return;\n    }\n\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      module: this.moduleName,\n      message,\n      metadata: meta\n    };\n\n    this.entries.push(entry);\n\n    // In production, you would implement external logging here\n    // For example:\n    // - Write to a database\n    // - Send to a logging service\n    // - Write to a file\n  }\n\n  /**\n   * Get collected log entries\n   */\n  getEntries(): LogEntry[] {\n    return [...this.entries];\n  }\n\n  /**\n   * Clear collected log entries\n   */\n  clearEntries(): void {\n    this.entries = [];\n  }\n\n  /**\n   * Configure the logger\n   * @param config Configuration options to apply\n   */\n  configure(config: Partial<LoggerConfig>): void {\n    this.config = {\n      ...this.config,\n      ...config\n    };\n  }\n\n  /**\n   * Get the current logger configuration\n   */\n  getConfig(): LoggerConfig {\n    return { ...this.config };\n  }\n}\n","// typescript/src/canonical.ts\nimport { GitHubStoreClient } from './client';\nimport { GitHubStoreConfig, LabelNames, StoredObject } from './types';\nimport { Logger } from './logging'; // Import a logger utility\n\n// Create a logger instance\nconst logger = new Logger('CanonicalStore');\n\n// Configuration for CanonicalStore\nexport interface CanonicalStoreConfig extends GitHubStoreConfig {\n  canonicalize?: boolean; // Whether to perform canonicalization by default\n}\n\n// Result type for alias creation\nexport interface AliasResult {\n  success: boolean;\n  sourceId: string;\n  targetId: string;\n}\n\n// The main CanonicalStore class\nexport class CanonicalStoreClient extends GitHubStoreClient {\n  private canonicalizeByDefault: boolean;\n  private visitedIds: Set<string>; // For circular reference detection\n\n  constructor(\n    token: string,\n    repo: string,\n    config: CanonicalStoreConfig = {}\n  ) {\n    super(token, repo, config);\n    this.canonicalizeByDefault = config.canonicalize ?? true;\n    this.visitedIds = new Set<string>();\n    \n    // Ensure special labels exist\n    this._ensureSpecialLabels().catch(err => {\n      logger.warn(`Could not ensure special labels exist: ${(err as Error).message}`);\n    });\n  }\n  \n  // Create special labels needed by the system\n  private async _ensureSpecialLabels(): Promise<void> {\n    const specialLabels = [\n      { name: LabelNames.GH_STORE, color: \"6f42c1\", description: \"All issues managed by gh-store system\" }\n    ];\n\n    try {\n      // Get existing labels\n      const existingLabelsResponse = await this.fetchFromGitHub<Array<{ name: string }>>(\"/labels\");\n      const existingLabels = new Set(existingLabelsResponse.map(label => label.name));\n\n      // Create any missing labels\n      for (const label of specialLabels) {\n        if (!existingLabels.has(label.name)) {\n          try {\n            await this.fetchFromGitHub(\"/labels\", {\n              method: \"POST\",\n              body: JSON.stringify(label)\n            });\n          } catch (error) {\n            logger.warn(`Could not create label ${label.name}: ${(error as Error).message}`);\n          }\n        }\n      }\n    } catch (error) {\n      logger.warn(`Could not ensure special labels exist: ${(error as Error).message}`);\n    }\n  }\n\n  // Resolve object ID to its canonical form\n  async resolveCanonicalObjectId(objectId: string, maxDepth: number = 5): Promise<string> {\n    // Reset visited IDs for each top-level resolution attempt\n    this.visitedIds = new Set<string>();\n    return this._resolveCanonicalIdInternal(objectId, maxDepth);\n  }\n\n  // Internal method for alias resolution with cycle detection\n  private async _resolveCanonicalIdInternal(objectId: string, maxDepth: number): Promise<string> {\n    if (maxDepth <= 0) {\n      logger.warn(`Maximum alias resolution depth reached for ${objectId}`);\n      return objectId;\n    }\n\n    // Detect circular references\n    if (this.visitedIds.has(objectId)) {\n      logger.warn(`Circular reference detected for ${objectId}`);\n      return objectId;\n    }\n\n    // Mark this ID as visited\n    this.visitedIds.add(objectId);\n\n    // Check if this is an alias\n    try {\n      const issues = await this.fetchFromGitHub<Array<{\n        number: number;\n        labels: Array<{ name: string }>;\n      }>>(\"/issues\", {\n        method: \"GET\",\n        params: {\n          labels: `${LabelNames.UID_PREFIX}${objectId},${LabelNames.ALIAS_TO_PREFIX}*`,\n          state: \"all\",\n        },\n      });\n\n      if (issues && issues.length > 0) {\n        for (const issue of issues) {\n          for (const label of issue.labels) {\n            if (label.name.startsWith(LabelNames.ALIAS_TO_PREFIX)) {\n              // Extract canonical object ID from label\n              const canonicalId = label.name.slice(LabelNames.ALIAS_TO_PREFIX.length);\n              \n              // Prevent self-referential loops\n              if (canonicalId === objectId) {\n                logger.error(`Self-referential alias detected for ${objectId}`);\n                return objectId;\n              }\n              \n              // Recurse to follow alias chain\n              return this._resolveCanonicalIdInternal(canonicalId, maxDepth - 1);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      logger.warn(`Error resolving canonical ID for ${objectId}: ${(error as Error).message}`);\n    }\n\n    // Not an alias, or couldn't resolve - assume it's canonical\n    return objectId;\n  }\n\n  // Override getObject to implement canonicalization\n  async getObject(objectId: string, options: { canonicalize?: boolean } = {}): Promise<StoredObject> {\n    const canonicalize = options.canonicalize ?? this.canonicalizeByDefault;\n    \n    if (canonicalize) {\n      const canonicalId = await this.resolveCanonicalObjectId(objectId);\n      if (canonicalId !== objectId) {\n        logger.info(`Object ${objectId} resolved to canonical object ${canonicalId}`);\n      }\n      return super.getObject(canonicalId);\n    } else {\n      // Direct fetch without canonicalization\n      return super.getObject(objectId);\n    }\n  }\n\n  // Create an alias relationship\n  async createAlias(sourceId: string, targetId: string): Promise<AliasResult> {\n    // 1. Verify source object exists\n    let sourceIssue;\n    try {\n      const sourceIssues = await this.fetchFromGitHub<Array<{ number: number }>>(\"/issues\", {\n        method: \"GET\",\n        params: {\n          labels: `${LabelNames.UID_PREFIX}${sourceId},${LabelNames.STORED_OBJECT}`,\n          state: \"all\",\n        },\n      });\n      \n      if (!sourceIssues || sourceIssues.length === 0) {\n        throw new Error(`Source object not found: ${sourceId}`);\n      }\n      \n      sourceIssue = sourceIssues[0];\n    } catch (error) {\n      throw new Error(`Error finding source object: ${(error as Error).message}`);\n    }\n    \n    // 2. Verify target object exists\n    try {\n      const targetIssues = await this.fetchFromGitHub<Array<{ number: number }>>(\"/issues\", {\n        method: \"GET\",\n        params: {\n          labels: `${LabelNames.UID_PREFIX}${targetId},${LabelNames.STORED_OBJECT}`,\n          state: \"all\",\n        },\n      });\n      \n      if (!targetIssues || targetIssues.length === 0) {\n        throw new Error(`Target object not found: ${targetId}`);\n      }\n    } catch (error) {\n      throw new Error(`Error finding target object: ${(error as Error).message}`);\n    }\n    \n    // 3. Check if this is already an alias\n    try {\n      const existingAliasLabels = await this.fetchFromGitHub<Array<{ name: string }>>(`/issues/${sourceIssue.number}/labels`);\n      \n      for (const label of existingAliasLabels) {\n        if (label.name.startsWith(LabelNames.ALIAS_TO_PREFIX)) {\n          throw new Error(`Object ${sourceId} is already an alias`);\n        }\n      }\n    } catch (error) {\n      if (!(error as Error).message.includes('already an alias')) {\n        throw new Error(`Error checking existing aliases: ${(error as Error).message}`);\n      } else {\n        throw error; // Rethrow \"already an alias\" error\n      }\n    }\n    \n    // 4. Create alias label if it doesn't exist\n    const aliasLabel = `${LabelNames.ALIAS_TO_PREFIX}${targetId}`;\n    try {\n      // Try to create the label - might fail if it already exists\n      try {\n        await this.fetchFromGitHub(\"/labels\", {\n          method: \"POST\",\n          body: JSON.stringify({\n            name: aliasLabel,\n            color: \"fbca04\"\n          })\n        });\n      } catch (error) {\n        // Label might already exist, continue\n        logger.warn(`Could not create label ${aliasLabel}: ${(error as Error).message}`);\n      }\n      \n      // Add label to source issue\n      await this.fetchFromGitHub(`/issues/${sourceIssue.number}/labels`, {\n        method: \"POST\",\n        body: JSON.stringify({\n          labels: [aliasLabel]\n        })\n      });\n      \n      return {\n        success: true,\n        sourceId,\n        targetId\n      };\n    } catch (error) {\n      throw new Error(`Failed to create alias: ${(error as Error).message}`);\n    }\n  }\n\n  // Find aliases in the repository\n  async findAliases(objectId?: string): Promise<Record<string, string>> {\n    const aliases: Record<string, string> = {};\n    \n    try {\n      if (objectId) {\n        // Find aliases for specific object\n        const aliasIssues = await this.fetchFromGitHub<Array<{\n          labels: Array<{ name: string }>;\n        }>>(\"/issues\", {\n          method: \"GET\",\n          params: {\n            labels: `${LabelNames.ALIAS_TO_PREFIX}${objectId}`,\n            state: \"all\",\n          },\n        });\n        \n        for (const issue of aliasIssues || []) {\n          const aliasId = this._extractObjectIdFromLabels(issue);\n          if (aliasId) {\n            aliases[aliasId] = objectId;\n          }\n        }\n      } else {\n        // Find all aliases\n        const aliasIssues = await this.fetchFromGitHub<Array<{\n          labels: Array<{ name: string }>;\n        }>>(\"/issues\", {\n          method: \"GET\",\n          params: {\n            labels: `${LabelNames.ALIAS_TO_PREFIX}*`,\n            state: \"all\",\n          },\n        });\n        \n        for (const issue of aliasIssues || []) {\n          const aliasId = this._extractObjectIdFromLabels(issue);\n          if (!aliasId) continue;\n          \n          // Find target of alias\n          for (const label of issue.labels) {\n            if (label.name.startsWith(LabelNames.ALIAS_TO_PREFIX)) {\n              const canonicalId = label.name.slice(LabelNames.ALIAS_TO_PREFIX.length);\n              aliases[aliasId] = canonicalId;\n              break;\n            }\n          }\n        }\n      }\n      \n      return aliases;\n    } catch (error) {\n      logger.warn(`Error finding aliases: ${(error as Error).message}`);\n      return {};\n    }\n  }\n\n  // Helper to extract object ID from labels\n  protected _extractObjectIdFromLabels(issue: { labels: Array<{ name: string }> }): string {\n    for (const label of issue.labels) {\n      if (label.name.startsWith(LabelNames.UID_PREFIX)) {\n        return label.name.slice(LabelNames.UID_PREFIX.length);\n      }\n    }\n    \n    throw new Error(`No UID label found with prefix ${LabelNames.UID_PREFIX}`);\n  }\n}\n"],"mappings":"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","names":["LabelNames","IssueCache","config","objectId","entry","issueNumber","metadata","lru","latestUpdate","index","CLIENT_VERSION","GitHubStoreClient","token","repo","config","IssueCache","path","options","url","key","value","headersObj","existingHeaders","response","data","issueNumber","type","payload","CLIENT_VERSION","objectId","cachedIssueNumber","issue","issues","createdAt","updatedAt","extraLabels","uidLabel","labels","initialState","comment","expectedLabels","label","changes","updatePayload","objects","meta","timestamp","comments","history","commentType","commentData","metadata","DEFAULT_CONFIG","mergeConfig","userConfig","validateToken","token","validateRepo","repo","ConfigError","message","TokenError","RepoError","DEFAULT_CONFIG","LOG_LEVEL_VALUES","Logger","moduleName","config","message","meta","level","entry","logger","Logger","CanonicalStoreClient","GitHubStoreClient","token","repo","config","err","specialLabels","existingLabelsResponse","existingLabels","label","error","objectId","maxDepth","issues","issue","canonicalId","options","sourceId","targetId","sourceIssue","sourceIssues","targetIssues","existingAliasLabels","aliasLabel","aliases","aliasIssues","aliasId"]}