var f=(i=>(i.GH_STORE="gh-store",i.STORED_OBJECT="stored-object",i.DEPRECATED="deprecated-object",i.UID_PREFIX="UID:",i.ALIAS_TO_PREFIX="ALIAS-TO:",i))(f||{});var m=class{constructor(e={}){this.cache=new Map,this.maxSize=e.maxSize??1e3,this.ttl=e.ttl??1e3*60*60,this.accessOrder=[]}get(e){let t=this.cache.get(e);if(t){if(Date.now()-t.lastAccessed>this.ttl){this.cache.delete(e),this.removeFromAccessOrder(e);return}return t.lastAccessed=Date.now(),this.updateAccessOrder(e),t.issueNumber}}set(e,t,r){if(this.cache.size>=this.maxSize&&!this.cache.has(e)){let s=this.accessOrder[this.accessOrder.length-1];s&&(this.cache.delete(s),this.removeFromAccessOrder(s))}this.cache.set(e,{issueNumber:t,lastAccessed:Date.now(),createdAt:r.createdAt,updatedAt:r.updatedAt}),this.updateAccessOrder(e)}remove(e){this.cache.delete(e),this.removeFromAccessOrder(e)}clear(){this.cache.clear(),this.accessOrder=[]}getStats(){return{size:this.cache.size,maxSize:this.maxSize,ttl:this.ttl}}shouldRefresh(e,t){let r=this.cache.get(e);return r?t>r.updatedAt:!0}updateAccessOrder(e){this.removeFromAccessOrder(e),this.accessOrder.unshift(e)}removeFromAccessOrder(e){let t=this.accessOrder.indexOf(e);t>-1&&this.accessOrder.splice(t,1)}};var y="0.11.1";var d=class{constructor(e,t,r={}){if(this.token=e,this.repo=t,!this.repo)throw new Error("Repository is required");this.config={baseLabel:r.baseLabel??"stored-object",uidPrefix:r.uidPrefix??"UID:",reactions:{processed:r.reactions?.processed??"+1",initialState:r.reactions?.initialState??"rocket"}},this.cache=new m(r.cache)}isPublic(){return this.token===null}async fetchFromGitHub(e,t={}){let r=new URL(`https://api.github.com/repos/${this.repo}${e}`);t.params&&(Object.entries(t.params).forEach(([a,n])=>{r.searchParams.append(a,n)}),delete t.params);let s={Accept:"application/vnd.github.v3+json"};if(t.headers){let a=t.headers;Object.keys(a).forEach(n=>{s[n]=a[n]})}this.token&&(s.Authorization=`token ${this.token}`);let i=await fetch(r.toString(),{...t,headers:s});if(!i.ok)throw new Error(`GitHub API error: ${i.status}`);return i.json()}createCommentPayload(e,t,r){let s={_data:e,_meta:{client_version:y,timestamp:new Date().toISOString(),update_mode:"append",issue_number:t}};return r&&(s.type=r),s}async getObject(e){let t=this.cache.get(e),r;if(t)try{r=await this.fetchFromGitHub(`/issues/${t}`),this._verifyIssueLabels(r,e)||(this.cache.remove(e),r=void 0)}catch{this.cache.remove(e)}if(!r){let c=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:["gh-store",this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"closed"}});if(!c||c.length===0)throw new Error(`No object found with ID: ${e}`);r=c[0]}if(!r?.body)throw new Error(`Invalid issue data received for ID: ${e}`);let s=JSON.parse(r.body),i=new Date(r.created_at),a=new Date(r.updated_at);return this.cache.set(e,r.number,{createdAt:i,updatedAt:a}),{meta:{objectId:e,label:`${this.config.uidPrefix}${e}`,issueNumber:r.number,createdAt:i,updatedAt:a,version:await this._getVersion(r.number)},data:s}}async createObject(e,t,r=[]){if(!this.token)throw new Error("Authentication required for creating objects");let s=`${this.config.uidPrefix}${e}`,i=["gh-store",this.config.baseLabel,s,...r],a=await this.fetchFromGitHub("/issues",{method:"POST",body:JSON.stringify({title:`Stored Object: ${e}`,body:JSON.stringify(t,null,2),labels:i})});this.cache.set(e,a.number,{createdAt:new Date(a.created_at),updatedAt:new Date(a.updated_at)});let n=this.createCommentPayload(t,a.number,"initial_state"),c=await this.fetchFromGitHub(`/issues/${a.number}/comments`,{method:"POST",body:JSON.stringify({body:JSON.stringify(n,null,2)})});return await this.fetchFromGitHub(`/issues/comments/${c.id}/reactions`,{method:"POST",body:JSON.stringify({content:this.config.reactions.processed})}),await this.fetchFromGitHub(`/issues/comments/${c.id}/reactions`,{method:"POST",body:JSON.stringify({content:this.config.reactions.initialState})}),await this.fetchFromGitHub(`/issues/${a.number}`,{method:"PATCH",body:JSON.stringify({state:"closed"})}),{meta:{objectId:e,label:s,issueNumber:a.number,createdAt:new Date(a.created_at),updatedAt:new Date(a.updated_at),version:1},data:t}}_verifyIssueLabels(e,t){let r=new Set([this.config.baseLabel,`${this.config.uidPrefix}${t}`]);return e.labels.some(s=>r.has(s.name))}async updateObject(e,t){if(!this.token)throw new Error("Authentication required for updating objects");let r=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"all"}});if(!r||r.length===0)throw new Error(`No object found with ID: ${e}`);let s=r[0],i=this.createCommentPayload(t,s.number);return await this.fetchFromGitHub(`/issues/${s.number}/comments`,{method:"POST",body:JSON.stringify({body:JSON.stringify(i,null,2)})}),await this.fetchFromGitHub(`/issues/${s.number}`,{method:"PATCH",body:JSON.stringify({state:"open"})}),this.getObject(e)}async listAll(){let e=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:this.config.baseLabel,state:"closed"}}),t={};for(let r of e)if(!r.labels.some(s=>s.name==="archived"))try{let s=this._getObjectIdFromLabels(r),i=JSON.parse(r.body),a={objectId:s,label:s,issueNumber:r.number,createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at),version:await this._getVersion(r.number)};t[s]={meta:a,data:i}}catch{continue}return t}async listUpdatedSince(e){let t=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:this.config.baseLabel,state:"closed",since:e.toISOString()}}),r={};for(let s of t)if(!s.labels.some(i=>i.name==="archived"))try{let i=this._getObjectIdFromLabels(s),a=JSON.parse(s.body),n=new Date(s.updated_at);if(n>e){let c={objectId:i,label:i,issueNumber:s.number,createdAt:new Date(s.created_at),updatedAt:n,version:await this._getVersion(s.number)};r[i]={meta:c,data:a}}}catch{continue}return r}async getObjectHistory(e){let t=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"all"}});if(!t||t.length===0)throw new Error(`No object found with ID: ${e}`);let r=t[0],s=await this.fetchFromGitHub(`/issues/${r.number}/comments`),i=[];for(let a of s)try{let n=JSON.parse(a.body),c="update",u,p={client_version:"legacy",timestamp:a.created_at,update_mode:"append"};typeof n=="object"?"_data"in n?(c=n.type||"update",u=n._data,p=n._meta||p):"type"in n&&n.type==="initial_state"?(c="initial_state",u=n.data):u=n:u=n,i.push({timestamp:a.created_at,type:c,data:u,commentId:a.id})}catch{continue}return i}async _getVersion(e){return(await this.fetchFromGitHub(`/issues/${e}/comments`)).length+1}_getObjectIdFromLabels(e){for(let t of e.labels)if(t.name!==this.config.baseLabel&&t.name.startsWith(this.config.uidPrefix))return t.name.slice(this.config.uidPrefix.length);throw new Error(`No UID label found with prefix ${this.config.uidPrefix}`)}};var h={baseLabel:"stored-object",uidPrefix:"UID:",reactions:{processed:"+1",initialState:"rocket"},retries:{maxAttempts:3,backoffFactor:2},rateLimit:{maxRequestsPerHour:1e3}};function H(o){return{...h,...o,reactions:{...h.reactions,...o.reactions},retries:{...h.retries,...o.retries},rateLimit:{...h.rateLimit,...o.rateLimit}}}function N(o){return/^gh[ps]_[a-zA-Z0-9]{36}$/.test(o)}function J(o){return/^[\w-]+\/[\w-]+$/.test(o)}var g=class extends Error{constructor(e){super(e),this.name="ConfigError"}},O=class extends g{constructor(e="Invalid GitHub token format"){super(e),this.name="TokenError"}},w=class extends g{constructor(e="Invalid repository format. Use owner/repo"){super(e),this.name="RepoError"}};var E={level:"info",silent:!1},A={error:3,warn:2,info:1,debug:0},b=class{constructor(e,t={}){this.entries=[];this.moduleName=e,this.config={...E,...t}}debug(e,t){this.log("debug",e,t)}info(e,t){this.log("info",e,t)}warn(e,t){this.log("warn",e,t)}error(e,t){this.log("error",e,t)}log(e,t,r){if(A[e]<A[this.config.level])return;let s={timestamp:new Date().toISOString(),level:e,module:this.moduleName,message:t,metadata:r};this.entries.push(s)}getEntries(){return[...this.entries]}clearEntries(){this.entries=[]}configure(e){this.config={...this.config,...e}}getConfig(){return{...this.config}}};var l=new b("CanonicalStore"),S=class extends d{constructor(e,t,r={}){super(e,t,r),this.canonicalizeByDefault=r.canonicalize??!0,this.visitedIds=new Set,this._ensureSpecialLabels().catch(s=>{l.warn(`Could not ensure special labels exist: ${s.message}`)})}async _ensureSpecialLabels(){let e=[{name:"gh-store",color:"6f42c1",description:"All issues managed by gh-store system"}];try{let t=await this.fetchFromGitHub("/labels"),r=new Set(t.map(s=>s.name));for(let s of e)if(!r.has(s.name))try{await this.fetchFromGitHub("/labels",{method:"POST",body:JSON.stringify(s)})}catch(i){l.warn(`Could not create label ${s.name}: ${i.message}`)}}catch(t){l.warn(`Could not ensure special labels exist: ${t.message}`)}}async resolveCanonicalObjectId(e,t=5){return this.visitedIds=new Set,this._resolveCanonicalIdInternal(e,t)}async _resolveCanonicalIdInternal(e,t){if(t<=0)return l.warn(`Maximum alias resolution depth reached for ${e}`),e;if(this.visitedIds.has(e))return l.warn(`Circular reference detected for ${e}`),e;this.visitedIds.add(e);try{let r=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:`UID:${e},ALIAS-TO:*`,state:"all"}});if(r&&r.length>0){for(let s of r)for(let i of s.labels)if(i.name.startsWith("ALIAS-TO:")){let a=i.name.slice("ALIAS-TO:".length);return a===e?(l.error(`Self-referential alias detected for ${e}`),e):this._resolveCanonicalIdInternal(a,t-1)}}}catch(r){l.warn(`Error resolving canonical ID for ${e}: ${r.message}`)}return e}async getObject(e,t={}){if(t.canonicalize??this.canonicalizeByDefault){let s=await this.resolveCanonicalObjectId(e);return s!==e&&l.info(`Object ${e} resolved to canonical object ${s}`),super.getObject(s)}else return super.getObject(e)}async createAlias(e,t){let r;try{let i=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:`UID:${e},stored-object`,state:"all"}});if(!i||i.length===0)throw new Error(`Source object not found: ${e}`);r=i[0]}catch(i){throw new Error(`Error finding source object: ${i.message}`)}try{let i=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:`UID:${t},stored-object`,state:"all"}});if(!i||i.length===0)throw new Error(`Target object not found: ${t}`)}catch(i){throw new Error(`Error finding target object: ${i.message}`)}try{let i=await this.fetchFromGitHub(`/issues/${r.number}/labels`);for(let a of i)if(a.name.startsWith("ALIAS-TO:"))throw new Error(`Object ${e} is already an alias`)}catch(i){throw i.message.includes("already an alias")?i:new Error(`Error checking existing aliases: ${i.message}`)}let s=`ALIAS-TO:${t}`;try{try{await this.fetchFromGitHub("/labels",{method:"POST",body:JSON.stringify({name:s,color:"fbca04"})})}catch(i){l.warn(`Could not create label ${s}: ${i.message}`)}return await this.fetchFromGitHub(`/issues/${r.number}/labels`,{method:"POST",body:JSON.stringify({labels:[s]})}),{success:!0,sourceId:e,targetId:t}}catch(i){throw new Error(`Failed to create alias: ${i.message}`)}}async findAliases(e){let t={};try{if(e){let r=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:`ALIAS-TO:${e}`,state:"all"}});for(let s of r||[]){let i=this._extractObjectIdFromLabels(s);i&&(t[i]=e)}}else{let r=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:"ALIAS-TO:*",state:"all"}});for(let s of r||[]){let i=this._extractObjectIdFromLabels(s);if(i){for(let a of s.labels)if(a.name.startsWith("ALIAS-TO:")){let n=a.name.slice("ALIAS-TO:".length);t[i]=n;break}}}}return t}catch(r){return l.warn(`Error finding aliases: ${r.message}`),{}}}_extractObjectIdFromLabels(e){for(let t of e.labels)if(t.name.startsWith("UID:"))return t.name.slice("UID:".length);throw new Error("No UID label found with prefix UID:")}};export{S as CanonicalStoreClient,g as ConfigError,h as DEFAULT_CONFIG,d as GitHubStoreClient,f as LabelNames,w as RepoError,O as TokenError,H as mergeConfig,J as validateRepo,N as validateToken};
//# sourceMappingURL=index.mjs.map