type Json = {
    [key: string]: Json;
} | Json[] | string | number | boolean | null;
interface ObjectMeta {
    objectId: string;
    label: string;
    issueNumber: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
}
interface StoredObject {
    meta: ObjectMeta;
    data: Json;
}
interface GitHubStoreConfig {
    baseLabel?: string;
    uidPrefix?: string;
    reactions?: {
        processed?: string;
        initialState?: string;
    };
}
interface CommentMeta {
    client_version: string;
    timestamp: string;
    update_mode: string;
    issue_number: number;
}
interface CommentPayload {
    _data: Json;
    _meta: CommentMeta;
    type?: string;
}
declare enum LabelNames {
    GH_STORE = "gh-store",
    STORED_OBJECT = "stored-object",
    DEPRECATED = "deprecated-object",
    UID_PREFIX = "UID:",
    ALIAS_TO_PREFIX = "ALIAS-TO:"
}

interface CacheConfig {
    maxSize?: number;
    ttl?: number;
}

declare class GitHubStoreClient {
    private token;
    private repo;
    private config;
    private cache;
    constructor(token: string | null, repo: string, config?: GitHubStoreConfig & {
        cache?: CacheConfig;
    });
    /**
     * Check if the client is operating in public (unauthenticated) mode
     * @returns True if client is using unauthenticated mode
     */
    isPublic(): boolean;
    /**
     * Makes a request to the GitHub API
     *
     * @param path - The API path to request (e.g., "/issues")
     * @param options - Request options including optional params
     * @returns The JSON response from the API
     */
    fetchFromGitHub<T>(path: string, options?: RequestInit & {
        params?: Record<string, string>;
    }): Promise<T>;
    private createCommentPayload;
    getObject(objectId: string): Promise<StoredObject>;
    createObject(objectId: string, data: Json, extraLabels?: string[]): Promise<StoredObject>;
    private _verifyIssueLabels;
    updateObject(objectId: string, changes: Json): Promise<StoredObject>;
    listAll(): Promise<Record<string, StoredObject>>;
    listUpdatedSince(timestamp: Date): Promise<Record<string, StoredObject>>;
    getObjectHistory(objectId: string): Promise<Array<{
        timestamp: string;
        type: string;
        data: Json;
        commentId: number;
    }>>;
    private _getVersion;
    private _getObjectIdFromLabels;
}

interface StoreConfig {
    baseLabel: string;
    uidPrefix: string;
    reactions: {
        processed: string;
        initialState: string;
    };
    retries: {
        maxAttempts: number;
        backoffFactor: number;
    };
    rateLimit: {
        maxRequestsPerHour: number;
    };
}
declare const DEFAULT_CONFIG: StoreConfig;
declare function mergeConfig(userConfig: Partial<StoreConfig>): StoreConfig;
declare function validateToken(token: string): boolean;
declare function validateRepo(repo: string): boolean;
declare class ConfigError extends Error {
    constructor(message: string);
}
declare class TokenError extends ConfigError {
    constructor(message?: string);
}
declare class RepoError extends ConfigError {
    constructor(message?: string);
}

interface CanonicalStoreConfig extends GitHubStoreConfig {
    canonicalize?: boolean;
}
interface AliasResult {
    success: boolean;
    sourceId: string;
    targetId: string;
}
declare class CanonicalStoreClient extends GitHubStoreClient {
    private canonicalizeByDefault;
    private visitedIds;
    constructor(token: string, repo: string, config?: CanonicalStoreConfig);
    private _ensureSpecialLabels;
    resolveCanonicalObjectId(objectId: string, maxDepth?: number): Promise<string>;
    private _resolveCanonicalIdInternal;
    getObject(objectId: string, options?: {
        canonicalize?: boolean;
    }): Promise<StoredObject>;
    createAlias(sourceId: string, targetId: string): Promise<AliasResult>;
    findAliases(objectId?: string): Promise<Record<string, string>>;
    protected _extractObjectIdFromLabels(issue: {
        labels: Array<{
            name: string;
        }>;
    }): string;
}

export { type AliasResult, CanonicalStoreClient, type CanonicalStoreConfig, type CommentMeta, type CommentPayload, ConfigError, DEFAULT_CONFIG, GitHubStoreClient, type GitHubStoreConfig, type Json, LabelNames, type ObjectMeta, RepoError, type StoreConfig, type StoredObject, TokenError, mergeConfig, validateRepo, validateToken };
