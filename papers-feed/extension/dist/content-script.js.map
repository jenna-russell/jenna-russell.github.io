{"version":3,"file":"content-script.js","sources":["../../utils/logger.ts","../../source-integration/link-processor.ts","../../source-integration/metadata-extractor.ts","../../source-integration/base-source.ts","../../source-integration/arxiv/index.ts","../../source-integration/openreview/index.ts","../../source-integration/nature/index.ts","../../source-integration/pnas/index.ts","../../source-integration/misc/index.ts","../../source-integration/registry.ts","../../content.ts"],"sourcesContent":["// utils/logger.ts\n// Logging utility wrapping loguru\n\n/**\n * Logger class for consistent logging throughout the extension\n */\nexport class Logger {\n  constructor(private module: string) {}\n  \n  /**\n   * Log debug message\n   */\n  debug(message: string, data?: any): void {\n    console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log info message\n   */\n  info(message: string, data?: any): void {\n    console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log warning message\n   */\n  warning(message: string, data?: any): void {\n    console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n\n  /**\n   * Alias for warning method (to match loguru API)\n   */\n  warn(message: string, data?: any): void {\n    this.warning(message, data);\n  }\n  \n  /**\n   * Log error message\n   */\n  error(message: string, data?: any): void {\n    console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n}\n\n/**\n * Loguru mock for browser extension use\n */\nclass LoguruMock {\n  /**\n   * Get logger for a module\n   */\n  getLogger(module: string): Logger {\n    return new Logger(module);\n  }\n}\n\n// Export singleton instance\nexport const loguru = new LoguruMock();\n","// extension/source-integration/link-processor.ts\n// Generic link detection and processing module\n\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('link-processor');\n\ninterface LinkPattern {\n  // Source integration ID\n  sourceId: string;\n  \n  // Regular expression to match URLs\n  pattern: RegExp;\n  \n  // Function to extract paper ID from URL\n  extractPaperId: (url: string) => string | null;\n}\n\nexport class LinkProcessor {\n  private patterns: LinkPattern[] = [];\n  private observer: MutationObserver | null = null;\n  private processedLinks = new Set<string>();\n  private onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void;\n  \n  constructor(onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void) {\n    this.onLinkFound = onLinkFound;\n    logger.debug('Link processor initialized');\n  }\n  \n  /**\n   * Register a new link pattern\n   */\n  registerPattern(pattern: LinkPattern): void {\n    this.patterns.push(pattern);\n    logger.debug(`Registered pattern for ${pattern.sourceId}`);\n  }\n  \n  /**\n   * Process all links in the document\n   */\n  processLinks(document: Document): void {\n    // Process all links in the document\n    const links = document.querySelectorAll<HTMLAnchorElement>('a[href]');\n    \n    links.forEach(link => {\n      // Use a unique identifier for this link\n      const linkId = this.getLinkId(link);\n      \n      // Skip if already processed\n      if (this.processedLinks.has(linkId)) {\n        return;\n      }\n      \n      this.processedLinks.add(linkId);\n      \n      // Check each pattern\n      for (const pattern of this.patterns) {\n        if (pattern.pattern.test(link.href)) {\n          const paperId = pattern.extractPaperId(link.href);\n          \n          if (paperId) {\n            // Call the callback\n            this.onLinkFound(pattern.sourceId, paperId, link);\n            break; // Stop after first match\n          }\n        }\n      }\n    });\n  }\n  \n  /**\n   * Start observing for DOM changes\n   */\n  startObserving(document: Document): void {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n    \n    this.observer = new MutationObserver((mutations) => {\n      let newLinks = false;\n      \n      mutations.forEach(mutation => {\n        mutation.addedNodes.forEach(node => {\n          if (node.nodeType === Node.ELEMENT_NODE) {\n            // If this is an anchor tag, check it\n            if ((node as Element).tagName === 'A') {\n              newLinks = true;\n            }\n            \n            // Check for any anchor tags within this element\n            const links = (node as Element).querySelectorAll('a[href]');\n            if (links.length > 0) {\n              newLinks = true;\n            }\n          }\n        });\n      });\n      \n      if (newLinks) {\n        this.processLinks(document);\n      }\n    });\n    \n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n    \n    logger.debug('Started observing for DOM changes');\n  }\n  \n  /**\n   * Create a unique ID for a link\n   */\n  private getLinkId(link: HTMLAnchorElement): string {\n    // Use href and position in document to create a unique ID\n    const path = this.getElementPath(link);\n    return `${link.href}|${path}`;\n  }\n  \n  /**\n   * Get element path in DOM for identification\n   */\n  private getElementPath(element: Element): string {\n    const path: string[] = [];\n    let current: Element | null = element;\n    \n    while (current && current !== document.body) {\n      let selector = current.tagName.toLowerCase();\n      \n      if (current.id) {\n        selector += `#${current.id}`;\n      } else {\n        const siblings = Array.from(current.parentElement?.children || []);\n        const index = siblings.indexOf(current) + 1;\n        if (siblings.length > 1) {\n          selector += `:nth-child(${index})`;\n        }\n      }\n      \n      path.unshift(selector);\n      current = current.parentElement;\n    }\n    \n    return path.join(' > ');\n  }\n  \n  /**\n   * Stop observing DOM changes\n   */\n  stopObserving(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n      logger.debug('Stopped observing DOM changes');\n    }\n  }\n}\n","// extension/source-integration/metadata-extractor.ts\n// Object-oriented metadata extraction system with customizable extraction methods\n\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('metadata-extractor');\n\nexport interface ExtractedMetadata {\n  title: string;\n  authors: string;\n  description: string;\n  publishedDate: string;\n  doi?: string;\n  journalName?: string;\n  tags?: string[];\n  url?: string;\n}\n\n// Constants for standard source types\nexport const SOURCE_TYPES = {\n  PDF: 'pdf',\n  URL: 'url',\n} as const;\n\nexport type SourceType = typeof SOURCE_TYPES[keyof typeof SOURCE_TYPES];\n\n/**\n * Base class for metadata extraction with customizable extraction methods\n * Each method can be overridden to provide source-specific extraction\n */\nexport class MetadataExtractor {\n  protected document: Document;\n  protected url: string;\n  \n  /**\n   * Create a new metadata extractor for a document\n   */\n  constructor(document: Document) {\n    this.document = document;\n    this.url = document.location.href;\n    logger.debug('Initialized metadata extractor for:', this.url);\n  }\n  \n  /**\n   * Helper method to get content from meta tags\n   */\n  protected getMetaContent(selector: string): string {\n    const element = this.document.querySelector(selector);\n    return element ? element.getAttribute('content') || '' : '';\n  }\n  \n  /**\n   * Extract and return all metadata fields\n   */\n  public extract(): ExtractedMetadata {\n    logger.debug('Extracting metadata from page:', this.url);\n    \n    const metadata: ExtractedMetadata = {\n      title: this.extractTitle(),\n      authors: this.extractAuthors(),\n      description: this.extractDescription(),\n      publishedDate: this.extractPublishedDate(),\n      doi: this.extractDoi(),\n      journalName: this.extractJournalName(),\n      tags: this.extractTags(),\n      url: this.url\n    };\n    \n    logger.debug('Metadata extraction complete:', metadata);\n    return metadata;\n  }\n  \n  /**\n   * Extract title from document\n   * Considers multiple metadata standards with priority order\n   */\n  protected extractTitle(): string {\n    // Title extraction - priority order\n    return (\n      // Dublin Core\n      this.getMetaContent('meta[name=\"DC.Title\"]') || this.getMetaContent('meta[name=\"dc.title\"]') || \n      // Citation\n      this.getMetaContent('meta[name=\"citation_title\"]') ||\n      // Open Graph\n      this.getMetaContent('meta[property=\"og:title\"]') ||\n      // Standard meta\n      this.getMetaContent('meta[name=\"title\"]') ||\n      // Fallback to document title\n      this.document.title\n    );\n  }\n  \n  /**\n   * Extract authors from document\n   * Handles multiple author formats and sources\n   */\n  protected extractAuthors(): string {\n    // Get all citation authors (some pages have multiple citation_author tags)\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n    \n    // Get all DC creators\n    const dcCreators: string[] = [];\n    this.document.querySelectorAll('meta[name=\"DC.Creator.PersonalName\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) dcCreators.push(content);\n    });\n    \n    // Individual author elements\n    const dcCreator = this.getMetaContent('meta[name=\"DC.Creator.PersonalName\"]') || this.getMetaContent('meta[name=\"dc.creator.personalname\"]') ;\n    const citationAuthor = this.getMetaContent('meta[name=\"citation_author\"]');\n    const ogAuthor = this.getMetaContent('meta[property=\"og:article:author\"]') ||\n                    this.getMetaContent('meta[name=\"author\"]');\n    \n    // Set authors with priority\n    if (dcCreators.length > 0) {\n      return dcCreators.join(', ');\n    } else if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    } else if (dcCreator) {\n      return dcCreator;\n    } else if (citationAuthor) {\n      return citationAuthor;\n    } else if (ogAuthor) {\n      return ogAuthor;\n    }\n    \n    return '';\n  }\n  \n  /**\n   * Extract description/abstract from document\n   */\n  protected extractDescription(): string {\n    return (\n      this.getMetaContent('meta[name=\"DC.Description\"]') || this.getMetaContent('meta[name=\"dc.description\"]') ||\n      this.getMetaContent('meta[name=\"citation_abstract\"]') ||\n      this.getMetaContent('meta[property=\"og:description\"]') ||\n      this.getMetaContent('meta[name=\"description\"]')\n    );\n  }\n  \n  /**\n   * Extract publication date from document\n   */\n  protected extractPublishedDate(): string {\n    return (\n      this.getMetaContent('meta[name=\"DC.Date.issued\"]') || this.getMetaContent('meta[name=\"dc.date.issued\"]') || this.getMetaContent('meta[name=\"dc.date\"]') || this.getMetaContent('meta[name=\"dc.Date\"]') || this.getMetaContent('meta[name=\"DC.Date\"]') || \n      this.getMetaContent('meta[name=\"citation_date\"]') ||\n      this.getMetaContent('meta[property=\"article:published_time\"]')\n    );\n  }\n  \n  /**\n   * Extract DOI (Digital Object Identifier) from document\n   */\n  protected extractDoi(): string {\n    return (\n      this.getMetaContent('meta[name=\"DC.Identifier.DOI\"]') || this.getMetaContent('meta[name=\"dc.identifier.doi\"]') ||\n      this.getMetaContent('meta[name=\"citation_doi\"]')\n    );\n  }\n  \n  /**\n   * Extract journal name from document\n   */\n  protected extractJournalName(): string {\n    return (\n      this.getMetaContent('meta[name=\"DC.Source\"]') || this.getMetaContent('meta[name=\"dc.source\"]') ||\n      this.getMetaContent('meta[name=\"citation_journal_title\"]')\n    );\n  }\n  \n  /**\n   * Extract keywords/tags from document\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"keywords\"]') ||\n                    this.getMetaContent('meta[name=\"DC.Subject\"]') || this.getMetaContent('meta[name=\"dc.subject\"]');\n    \n    if (keywords) {\n      return keywords.split(',').map(tag => tag.trim());\n    }\n    \n    return [];\n  }\n  \n  /**\n   * Determine if the current URL is a PDF\n   */\n  public isPdf(): boolean {\n    return isPdfUrl(this.url);\n  }\n  \n  /**\n   * Get the source type (PDF or URL)\n   */\n  public getSourceType(): SourceType {\n    return this.isPdf() ? SOURCE_TYPES.PDF : SOURCE_TYPES.URL;\n  }\n  \n  /**\n   * Generate a paper ID for the current URL\n   */\n  public generatePaperId(): string {\n    return generatePaperIdFromUrl(this.url);\n  }\n}\n\n/**\n * Create a common metadata extractor for a document\n * Factory function for creating the default extractor\n */\nexport function createMetadataExtractor(document: Document): MetadataExtractor {\n  return new MetadataExtractor(document);\n}\n\n/**\n * Extract common metadata from a document\n * Convenience function for quick extraction\n */\nexport function extractCommonMetadata(document: Document): ExtractedMetadata {\n  return createMetadataExtractor(document).extract();\n}\n\n/**\n * Generate a paper ID from a URL\n * Creates a consistent hash-based identifier\n */\nexport function generatePaperIdFromUrl(url: string): string {\n  // Use a basic hash function to create an ID from the URL\n  let hash = 0;\n  for (let i = 0; i < url.length; i++) {\n    const char = url.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  \n  // Create a positive hexadecimal string\n  const positiveHash = Math.abs(hash).toString(16).toUpperCase();\n  \n  // Use the first 8 characters as the ID\n  return positiveHash.substring(0, 8);\n}\n\n/**\n * Determine if a URL is a PDF\n */\nexport function isPdfUrl(url: string): boolean {\n  return url.toLowerCase().endsWith('.pdf');\n}\n","// extension/source-integration/base-source.ts\n// Base class for source integrations with default identifier formatting\n// and metadata extraction capability\n\nimport { SourceIntegration } from './types';\nimport { PaperMetadata } from '../papers/types';\nimport { loguru } from '../utils/logger';\nimport { \n  MetadataExtractor, \n  createMetadataExtractor,\n  generatePaperIdFromUrl\n} from './metadata-extractor';\n\nconst logger = loguru.getLogger('base-source');\n\n/**\n * Base class for source integrations\n * Provides default implementations for all methods\n * Specific sources can override as needed\n */\nexport class BaseSourceIntegration implements SourceIntegration {\n  // Default properties - set for generic web pages\n  readonly id: string = 'url';\n  readonly name: string = 'Web Page';\n  readonly urlPatterns: RegExp[] = [\n    /^https?:\\/\\/(?!.*\\.pdf($|\\?|#)).*$/i  // Match HTTP/HTTPS URLs that aren't PDFs\n  ];\n  readonly contentScriptMatches: string[] = [];\n\n  /**\n   * Check if this integration can handle the given URL\n   * Default implementation checks against urlPatterns\n   */\n  canHandleUrl(url: string): boolean {\n    return this.urlPatterns.some(pattern => pattern.test(url));\n  }\n\n  /**\n   * Extract paper ID from URL\n   * Default implementation creates a hash from the URL\n   */\n  extractPaperId(url: string): string | null {\n    return generatePaperIdFromUrl(url);\n  }\n  \n  /**\n   * Create a metadata extractor for the given document\n   * Override this method to provide a custom extractor for your source\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return createMetadataExtractor(document);\n  }\n  \n  /**\n   * Extract metadata from a page\n   * Default implementation uses common metadata extraction\n   */\n  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {\n    try {\n      logger.debug(`Extracting metadata using base extractor for ID: ${paperId}`);\n      \n      // Create a metadata extractor for this document\n      const extractor = this.createMetadataExtractor(document);\n      \n      // Extract metadata\n      const extracted = extractor.extract();\n      const url = document.location.href;\n      \n      // Determine source type (PDF or URL)\n      const sourceType = extractor.getSourceType();\n      \n      // Create PaperMetadata object\n      return {\n        sourceId: this.id,\n        //paperId: this.formatPaperId(paperId),\n        paperId: paperId,\n        url: url,\n        title: extracted.title || document.title || paperId,\n        authors: extracted.authors || '',\n        abstract: extracted.description || '',\n        timestamp: new Date().toISOString(),\n        rating: 'novote',\n        publishedDate: extracted.publishedDate || '',\n        tags: extracted.tags || [],\n        doi: extracted.doi,\n        journalName: extracted.journalName,\n        sourceType: sourceType // Store the source type for reference\n      };\n    } catch (error) {\n      logger.error('Error extracting metadata with base extractor', error);\n      return null;\n    }\n  }\n  \n  /**\n   * Format a paper identifier for this source\n   * Default implementation uses the format: sourceId.paperId\n   */\n  formatPaperId(paperId: string): string {\n    return `${this.id}.${paperId}`;\n  }\n  \n  /**\n   * Parse a paper identifier specific to this source\n   * Default implementation handles source.paperId format and extracts paperId\n   */\n  parsePaperId(identifier: string): string | null {\n    const prefix = `${this.id}.`;\n    \n    if (identifier.startsWith(prefix)) {\n      return identifier.substring(prefix.length);\n    }\n    \n    // Try legacy format (sourceId:paperId)\n    const legacyPrefix = `${this.id}:`;\n    if (identifier.startsWith(legacyPrefix)) {\n      logger.debug(`Parsed legacy format identifier: ${identifier}`);\n      return identifier.substring(legacyPrefix.length);\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Format a storage object ID for this source\n   * Default implementation uses the format: type:sourceId.paperId\n   */\n  formatObjectId(type: string, paperId: string): string {\n    return `${type}:${this.formatPaperId(paperId)}`;\n  }\n}\n","// extension/source-integration/arxiv/index.ts\n// ArXiv integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { PaperMetadata } from '../../papers/types';\nimport { MetadataExtractor, ExtractedMetadata } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('arxiv-integration');\n\n/**\n * Custom metadata extractor for arXiv pages\n */\nclass ArxivMetadataExtractor extends MetadataExtractor {\n  private apiMetadata?: Partial<ExtractedMetadata>;\n  \n  constructor(document: Document, apiMetadata?: Partial<ExtractedMetadata>) {\n    super(document);\n    this.apiMetadata = apiMetadata;\n  }\n  \n  /**\n   * Override title extraction to use API data if available\n   */\n  protected extractTitle(): string {\n    if (this.apiMetadata?.title) {\n      return this.apiMetadata.title;\n    }\n    \n    return super.extractTitle();\n  }\n  \n  /**\n   * Override authors extraction to use API data if available\n   */\n  protected extractAuthors(): string {\n    if (this.apiMetadata?.authors) {\n      return this.apiMetadata.authors;\n    }\n    \n    // arXiv-specific selectors\n    const authorLinks = this.document.querySelectorAll('.authors a');\n    if (authorLinks.length > 0) {\n      return Array.from(authorLinks)\n        .map(link => link.textContent?.trim())\n        .filter(Boolean)\n        .join(', ');\n    }\n    \n    return super.extractAuthors();\n  }\n  \n  /**\n   * Override description extraction to use API data if available\n   */\n  protected extractDescription(): string {\n    if (this.apiMetadata?.description) {\n      return this.apiMetadata.description;\n    }\n    \n    // arXiv-specific selectors\n    const abstract = this.document.querySelector('.abstract')?.textContent?.trim();\n    if (abstract) {\n      // Remove \"Abstract:\" prefix if present\n      return abstract.replace(/^Abstract:\\s*/i, '');\n    }\n    \n    return super.extractDescription();\n  }\n  \n  /**\n   * Override published date extraction to use API data if available\n   */\n  protected extractPublishedDate(): string {\n    if (this.apiMetadata?.publishedDate) {\n      return this.apiMetadata.publishedDate;\n    }\n    \n    // arXiv-specific date extraction\n    const datelineElement = this.document.querySelector('.dateline');\n    if (datelineElement) {\n      const dateText = datelineElement.textContent;\n      const dateMatch = dateText?.match(/\\(Submitted on ([^)]+)\\)/);\n      if (dateMatch) {\n        return dateMatch[1];\n      }\n    }\n    \n    return super.extractPublishedDate();\n  }\n  \n  /**\n   * Override DOI extraction to use API data if available\n   */\n  protected extractDoi(): string {\n    return this.apiMetadata?.doi || super.extractDoi();\n  }\n  \n  /**\n   * Override journal extraction to use API data if available\n   */\n  protected extractJournalName(): string {\n    return this.apiMetadata?.journalName || super.extractJournalName();\n  }\n  \n  /**\n   * Override tags extraction to use API data if available\n   */\n  protected extractTags(): string[] {\n    if (this.apiMetadata?.tags) {\n      return this.apiMetadata.tags;\n    }\n    \n    // arXiv-specific category extraction\n    const subjects = this.document.querySelector('.subjects')?.textContent?.trim();\n    if (subjects) {\n      return subjects.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n    \n    return super.extractTags();\n  }\n}\n\n/**\n * ArXiv integration with custom metadata extraction\n */\nexport class ArXivIntegration extends BaseSourceIntegration {\n  readonly id = 'arxiv';\n  readonly name = 'arXiv.org';\n  \n  // URL patterns for papers\n  readonly urlPatterns = [\n    /arxiv\\.org\\/(abs|pdf|html)\\/([0-9.]+)/,\n    /arxiv\\.org\\/\\w+\\/([0-9.]+)/\n  ];\n  \n  // Content script matches\n  // readonly contentScriptMatches = [\n  //   \"*://*.arxiv.org/*\"\n  // ];\n\n  // ArXiv API endpoint\n  private readonly API_BASE_URL = 'https://export.arxiv.org/api/query';\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    for (const pattern of this.urlPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        return match[2] || match[1]; // The capture group with the paper ID\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Create a custom metadata extractor for arXiv\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new ArxivMetadataExtractor(document);\n  }\n\n  /**\n   * Fetch metadata from ArXiv API\n   */\n  private async fetchFromApi(paperId: string): Promise<Partial<ExtractedMetadata> | null> {\n    try {\n      const apiUrl = `${this.API_BASE_URL}?id_list=${paperId}`;\n      logger.debug(`Fetching from ArXiv API: ${apiUrl}`);\n      \n      const response = await fetch(apiUrl);\n      if (!response.ok) {\n        logger.error(`ArXiv API request failed with status: ${response.status}`);\n        return null;\n      }\n      \n      const xmlText = await response.text();\n      \n      // Parse XML to JSON\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(xmlText, 'text/xml');\n      \n      // Convert XML to a more manageable format\n      const entry = xmlDoc.querySelector('entry');\n      if (!entry) {\n        logger.warn('No entry found in ArXiv API response');\n        return null;\n      }\n      \n      // Extract metadata from XML\n      const title = entry.querySelector('title')?.textContent?.trim() || '';\n      const summary = entry.querySelector('summary')?.textContent?.trim() || '';\n      const published = entry.querySelector('published')?.textContent?.trim() || '';\n      \n      // Extract authors\n      const authorElements = entry.querySelectorAll('author name');\n      const authors = Array.from(authorElements)\n        .map(el => el.textContent?.trim())\n        .filter(Boolean)\n        .join(', ');\n      \n      // Extract DOI if available\n      const doi = entry.querySelector('arxiv\\\\:doi, doi')?.textContent?.trim();\n      \n      // Extract journal reference if available\n      const journalRef = entry.querySelector('arxiv\\\\:journal_ref, journal_ref')?.textContent?.trim();\n      \n      // Extract categories\n      const categoryElements = entry.querySelectorAll('category');\n      const categories = Array.from(categoryElements)\n        .map(el => el.getAttribute('term'))\n        .filter(Boolean) as string[];\n      \n      return {\n        title,\n        authors,\n        description: summary,\n        publishedDate: published,\n        doi,\n        journalName: journalRef,\n        tags: categories\n      };\n      \n    } catch (error) {\n      logger.error('Error fetching from ArXiv API', error);\n      return null;\n    }\n  }\n\n  /**\n   * Extract metadata from page or fetch from API\n   * Override parent method to handle the API fallback\n   */\n  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {\n    try {\n      logger.info(`Extracting metadata for arXiv ID: ${paperId}`);\n      \n      // Try to extract from page first\n      const extractor = this.createMetadataExtractor(document);\n      const pageMetadata = extractor.extract();\n      \n      // Check if we have the essential fields\n      const hasTitle = pageMetadata.title && pageMetadata.title !== document.title;\n      const hasAuthors = pageMetadata.authors && pageMetadata.authors.length > 0;\n      const hasAbstract = pageMetadata.description && pageMetadata.description.length > 0;\n      \n      if (hasTitle && hasAuthors && hasAbstract) {\n        logger.debug('Successfully extracted complete metadata from page');\n        return this.convertToPageMetadata(pageMetadata, paperId, extractor.getSourceType());\n      }\n      \n      // If page extraction is incomplete, fetch from API\n      logger.info('Page metadata incomplete, fetching from ArXiv API');\n      const apiMetadata = await this.fetchFromApi(paperId);\n      \n      if (!apiMetadata) {\n        logger.warn('Failed to fetch metadata from ArXiv API, using partial page data');\n        return this.convertToPageMetadata(pageMetadata, paperId, extractor.getSourceType());\n      }\n      \n      // Create a new extractor with API data\n      const enhancedExtractor = new ArxivMetadataExtractor(document, apiMetadata);\n      const mergedMetadata = enhancedExtractor.extract();\n      \n      logger.debug('Merged metadata from page and API', mergedMetadata);\n      return this.convertToPageMetadata(mergedMetadata, paperId, enhancedExtractor.getSourceType());\n      \n    } catch (error) {\n      logger.error('Error extracting metadata for arXiv', error);\n      return null;\n    }\n  }\n\n  /**\n   * Convert ExtractedMetadata to PaperMetadata\n   */\n  private convertToPageMetadata(extracted: ExtractedMetadata, paperId: string, sourceType: string): PaperMetadata {\n    return {\n      sourceId: this.id,\n      paperId: paperId,\n      url: extracted.url || '',\n      title: extracted.title,\n      authors: extracted.authors,\n      abstract: extracted.description,\n      timestamp: new Date().toISOString(),\n      rating: 'novote',\n      publishedDate: extracted.publishedDate,\n      tags: extracted.tags || [],\n      doi: extracted.doi,\n      journalName: extracted.journalName,\n      sourceType: sourceType\n    };\n  }\n}\n\n// Export a singleton instance that can be used by both background and content scripts\nexport const arxivIntegration = new ArXivIntegration();\n","// extension/source-integration/openreview/index.ts\n// OpenReview integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { PaperMetadata } from '../../papers/types';\nimport { MetadataExtractor, createMetadataExtractor, ExtractedMetadata } from '..//metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('openreview-integration');\n\n/**\n * Custom metadata extractor for OpenReview pages\n */\nclass OpenReviewMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract metadata from OpenReview pages\n   */\n  public extract(): ExtractedMetadata {\n    // First try to extract using standard methods\n    const baseMetadata = super.extract();\n    \n    try {\n      // Get title from OpenReview-specific elements\n      const title = this.document.querySelector('.citation_title')?.textContent || \n                   this.document.querySelector('.forum-title h2')?.textContent;\n      \n      // Get authors\n      const authorElements = Array.from(this.document.querySelectorAll('.forum-authors a'));\n      const authors = authorElements\n        .map(el => el.textContent)\n        .filter(Boolean)\n        .join(', ');\n      \n      // Get abstract\n      const abstract = this.document.querySelector('meta[name=\"citation_abstract\"]')?.getAttribute('content') ||\n                     Array.from(this.document.querySelectorAll('.note-content-field'))\n                       .find(el => el.textContent?.includes('Abstract'))\n                       ?.nextElementSibling?.textContent;\n      \n      // Get publication date\n      const dateText = this.document.querySelector('.date.item')?.textContent;\n      let publishedDate = '';\n      if (dateText) {\n        const dateMatch = dateText.match(/Published: ([^,]+)/);\n        if (dateMatch) {\n          publishedDate = dateMatch[1];\n        }\n      }\n      \n      // Get DOI if available\n      const doi = this.document.querySelector('meta[name=\"citation_doi\"]')?.getAttribute('content') || '';\n      \n      // Get conference/journal name\n      const venueElements = this.document.querySelectorAll('.forum-meta .item');\n      let venue = '';\n      for (let i = 0; i < venueElements.length; i++) {\n        const el = venueElements[i];\n        if (el.querySelector('.glyphicon-folder-open')) {\n          venue = el.textContent?.trim() || '';\n          break;\n        }\n      }\n      \n      // Get tags/keywords\n      const keywordsElement = Array.from(this.document.querySelectorAll('.note-content-field'))\n        .find(el => el.textContent?.includes('Keywords'));\n      let tags: string[] = [];\n      if (keywordsElement) {\n        const keywordsValue = keywordsElement.nextElementSibling?.textContent;\n        if (keywordsValue) {\n          tags = keywordsValue.split(',').map(tag => tag.trim());\n        }\n      }\n      \n      return {\n        title: title || baseMetadata.title,\n        authors: authors || baseMetadata.authors,\n        description: abstract || baseMetadata.description,\n        publishedDate: publishedDate || baseMetadata.publishedDate,\n        doi: doi || baseMetadata.doi,\n        journalName: venue || baseMetadata.journalName,\n        tags: tags.length ? tags : baseMetadata.tags,\n        url: this.url\n      };\n    } catch (error) {\n      logger.error('Error during OpenReview-specific extraction', error);\n      return baseMetadata;\n    }\n  }\n}\n\n/**\n * OpenReview integration with custom metadata extraction\n */\nexport class OpenReviewIntegration extends BaseSourceIntegration {\n  readonly id = 'openreview';\n  readonly name = 'OpenReview';\n  \n  // URL patterns for papers\n  readonly urlPatterns = [\n    /openreview\\.net\\/forum\\?id=([a-zA-Z0-9]+)/,\n    /openreview\\.net\\/pdf\\?id=([a-zA-Z0-9]+)/\n  ];\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    for (const pattern of this.urlPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        return match[1]; // The capture group with the paper ID\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Create a custom metadata extractor for OpenReview\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new OpenReviewMetadataExtractor(document);\n  }\n\n  /**\n   * Extract metadata from page\n   * Override parent method to handle OpenReview-specific extraction\n   */\n  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {\n    logger.info(`Extracting metadata for OpenReview ID: ${paperId}`);\n    \n    // Extract metadata using our custom extractor\n    const metadata = await super.extractMetadata(document, paperId);\n    \n    if (metadata) {\n      // Add any OpenReview-specific metadata processing here\n      logger.debug('Extracted metadata from OpenReview page');\n      \n      // Check if we're on a PDF page and adjust metadata accordingly\n      if (document.location.href.includes('/pdf?id=')) {\n        metadata.sourceType = 'pdf';\n      }\n    }\n    \n    return metadata;\n  }\n}\n\n// Export a singleton instance that can be used by both background and content scripts\nexport const openReviewIntegration = new OpenReviewIntegration();\n","// extension/source-integration/nature/index.ts\n// Nature.com integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { PaperMetadata } from '../../papers/types';\nimport { MetadataExtractor, ExtractedMetadata } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('nature-integration');\n\n/**\n * Custom metadata extractor for Nature.com pages\n */\nclass NatureMetadataExtractor extends MetadataExtractor {\n  /**\n   * Override title extraction to use meta tag first\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') || \n                      this.getMetaContent('meta[property=\"og:title\"]');\n    return metaTitle || super.extractTitle();\n  }\n  \n  /**\n   * Override authors extraction to use meta tag first\n   */\n  protected extractAuthors(): string {\n    const metaAuthors = this.getMetaContent('meta[name=\"citation_author\"]');\n    if (metaAuthors) {\n      return metaAuthors;\n    }\n    // Fallback to HTML extraction\n    const authorElements = this.document.querySelectorAll('.c-article-author-list__item');\n    if (authorElements.length > 0) {\n      return Array.from(authorElements)\n        .map(el => el.textContent?.trim())\n        .filter(Boolean)\n        .join(', ');\n    }\n    return super.extractAuthors();\n  }\n  \n  /**\n   * Extract keywords/tags from document\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"dc.subject\"]');\n    \n    if (keywords) {\n      return keywords.split(',').map(tag => tag.trim());\n    }\n    \n    return [];\n  }\n  \n\n  /**\n   * Override description extraction to use meta tag first\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Override published date extraction to use meta tag\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') || super.extractPublishedDate();\n  }\n\n  /**\n   * Override DOI extraction to use meta tag\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') || super.extractDoi();\n  }\n}\n\n/**\n * Nature.com integration with custom metadata extraction\n */\nexport class NatureIntegration extends BaseSourceIntegration {\n  readonly id = 'nature';\n  readonly name = 'Nature'; \n\n  // URL pattern for Nature articles with capture group for ID\n  readonly urlPatterns = [\n    /nature\\.com\\/articles\\/([^?]+)/,\n  ];\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    const match = url.match(this.urlPatterns[0]);\n    return match ? match[1] : null;\n  }\n\n  /**\n   * Create a custom metadata extractor for Nature.com\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new NatureMetadataExtractor(document);\n  }\n}\n\n// Export a singleton instance \nexport const natureIntegration = new NatureIntegration();\n","// extension/source-integration/pnas/index.ts\nimport { BaseSourceIntegration } from '../base-source';\n\nexport class PnasIntegration extends BaseSourceIntegration {\n  readonly id = 'pnas';\n  readonly name = 'PNAS'; \n\n  readonly urlPatterns = [\n    /pnas\\.org\\/doi\\/10\\.1073\\/pnas\\.([0-9]+)/\n  ];\n\n  // upstream BaseSourceIntegration.extractPaperId should default to this behavior when able\n  extractPaperId(url: string): string | null {\n    const match = url.match(this.urlPatterns[0]);\n    return match ? match[1] : null;\n  }\n}\n\nexport const pnasIntegration = new PnasIntegration();\n","// extension/source-integration/misc/index.ts\n/*\n * Catch-all for registering with URL pattern only\n */\nimport { BaseSourceIntegration } from '../base-source';\n\nexport class MiscIntegration extends BaseSourceIntegration {\n  readonly id = 'url-misc';\n  readonly name = 'misc tracked url';\n\n  readonly urlPatterns = []; // set this empty to disable attaching the content injection icon thing\n    \n  // add URLs here to track\n  readonly contentScriptMatches = [\n    \"sciencedirect.com/science/article/\",\n    \"philpapers.org/rec/\",\n    \"proceedings.neurips.cc/paper_files/paper/\",\n    \"journals.sagepub.com/doi/\",\n    \"link.springer.com/article/\",\n    \".science.org/doi/\",\n    \"journals.aps.org/prx/abstract/\",\n    \"onlinelibrary.wiley.com/doi/\",\n    \"cell.com/trends/cognitive-sciences/fulltext/\",\n    \"researchgate.net/publication/\",\n    \"psycnet.apa.org/record/\",\n    \"biorxiv.org/content/\",\n    \"osf.io/preprints/\",\n    \"frontiersin.org/journals/\",\n    \"jstor.org/\",\n    \"proceedings.mlr.press/\",\n    \"journals.plos.org/plosone/article\",\n    \"ieeexplore.ieee.org/document/\",\n    \"royalsocietypublishing.org/doi/\",\n    \"papers.nips.cc/paper_files/paper/\",\n    \"philarchive.org/archive/\",\n    \"tandfonline.com/doi/\",\n    \"iopscience.iop.org/article/\",\n    \"academic.oup.com/brain/article/\",\n    \"elifesciences.org/articles/\",\n    \"escholarship.org/content/\",\n    \"pmc.ncbi.nlm.nih.gov/articles/\",\n    \"pubmed.ncbi.nlm.nih.gov/\",\n    \"openaccess.thecvf.com/content/\",\n    \"zenodo.org/records/\",\n    \"journals.asm.org/doi/full/\",\n    \"physoc.onlinelibrary.wiley.com/doi/full/\",\n    \"storage.courtlistener.com/recap/\",\n    \"bmj.com/content/\",\n    \"ntsb.gov/investigations/pages\",\n    \"ntsb.gov/investigations/AccidentReports\",\n    \"aclanthology.org/\",\n    \"journals.ametsoc.org/view/journals/\",\n    \n    \"substack.com/p/\",\n    \"citeseerx.\",\n    \"/doi/\",\n    \"/pdf/\",\n\n  ];\n\n  canHandleUrl(url: string): boolean {\n    return this.contentScriptMatches.some(pattern => url.includes(pattern));\n  }\n}\n\nexport const miscIntegration = new MiscIntegration();\n","// extension/source-integration/registry.ts\n// Central registry for all source integrations\n\nimport { SourceIntegration } from './types';\nimport { arxivIntegration } from './arxiv';\nimport { openReviewIntegration } from './openreview';\nimport { natureIntegration } from './nature';\nimport { pnasIntegration } from './pnas';\nimport { miscIntegration } from './misc';\n\nexport const sourceIntegrations: SourceIntegration[] = [\n  arxivIntegration,\n  openReviewIntegration,\n  natureIntegration,\n  pnasIntegration,\n  miscIntegration,\n];\n\n/*     *     *     *     */\n\nexport function getAllIntegrations(): SourceIntegration[] {\n  return sourceIntegrations;\n}\n\nexport function getIntegrationById(id: string): SourceIntegration | undefined {\n  return sourceIntegrations.find(integration => integration.id === id);\n}\n\nexport function getAllContentScriptMatches(): string[] {\n  return sourceIntegrations.flatMap(integration => integration.contentScriptMatches);\n}\n","// content.ts\n// Content script with simplified session tracking\n\nimport { LinkProcessor } from './source-integration/link-processor';\nimport { SourceIntegration, Message } from './source-integration/types';\nimport { PaperMetadata } from './papers/types';\nimport { loguru } from './utils/logger';\nimport { BaseSourceIntegration } from './source-integration/base-source';\nimport { generatePaperIdFromUrl } from './source-integration/metadata-extractor';\n\n// Import from registry instead of individual sources\nimport { sourceIntegrations } from './source-integration/registry';\n\nconst logger = loguru.getLogger('content-script');\n\nlogger.info('Paper Tracker content script loaded');\n\n// Base source for fallback processing\nconst baseSource = new BaseSourceIntegration();\n\n// Track active popup\nlet activePopup: HTMLElement | null = null;\n\n// Heartbeat interval\nlet heartbeatInterval: number | null = null;\nconst HEARTBEAT_INTERVAL = 5000; // 5 seconds\n\n// Track tab visibility\nlet isTabVisible = true;\n\n// Track current session\nlet currentSession: { sourceId: string; paperId: string } | null = null;\n\n// Create link processor\nconst linkProcessor = new LinkProcessor((sourceId, paperId, link) => {\n  // Callback when link is found\n  injectAnnotationButton(link, sourceId, paperId);\n});\n\n// Initialize sources\nfunction initializeSources() {\n  // Register each source with the link processor\n  for (const source of sourceIntegrations) {\n    logger.debug(`Initializing source: ${source.id}`);\n    \n    // Register patterns with link processor\n    source.urlPatterns.forEach(pattern => {\n      linkProcessor.registerPattern({\n        sourceId: source.id,\n        pattern,\n        extractPaperId: (url: string) => source.extractPaperId(url)\n      });\n    });\n  }\n}\n\n// Inject common styles\nfunction injectStyles() {\n  if (document.getElementById('paper-tracker-styles')) {\n    return; // Already injected\n  }\n  \n  const styles = `\n  .paper-annotator {\n    display: inline-block;\n    margin-left: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    opacity: 0.7;\n    transition: opacity 0.2s;\n    vertical-align: baseline;\n  }\n\n  .paper-annotator:hover {\n    opacity: 1;\n  }\n\n  .paper-popup-wrapper {\n    position: fixed;\n    z-index: 10000;\n  }\n\n  .paper-popup {\n    position: relative;\n    background: white;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n    padding: 12px;\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n    width: 300px;\n    box-sizing: border-box;\n  }\n\n  .paper-popup-header {\n    font-weight: bold;\n    margin-bottom: 8px;\n    line-height: 1.4;\n    font-size: 1em;\n  }\n\n  .paper-popup-meta {\n    color: #666;\n    font-size: 0.85em;\n    margin-bottom: 12px;\n    line-height: 1.4;\n  }\n\n  .paper-popup-buttons {\n    display: flex;\n    gap: 8px;\n    margin: 8px 0;\n  }\n\n  .paper-popup button {\n    padding: 6px 12px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    background: #f5f5f5;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    font-size: 0.9em;\n  }\n\n  .paper-popup button:hover {\n    background: #e8e8e8;\n    border-color: #ccc;\n  }\n\n  .paper-popup button.active {\n    background: #e0e0e0;\n    border-color: #aaa;\n  }\n\n  .paper-popup textarea {\n    width: calc(100% - 16px);\n    min-height: 80px;\n    margin: 8px 0;\n    padding: 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    resize: vertical;\n    font-family: inherit;\n    font-size: 0.9em;\n    line-height: 1.4;\n    box-sizing: border-box;\n  }\n\n  .paper-popup textarea:focus {\n    outline: none;\n    border-color: #aaa;\n  }\n\n  .paper-popup-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n    margin-top: 12px;\n  }\n\n  .paper-popup .save-button {\n    background: #2563eb;\n    color: white;\n    border-color: #2563eb;\n  }\n\n  .paper-popup .save-button:hover {\n    background: #1d4ed8;\n    border-color: #1d4ed8;\n  }\n  `;\n  \n  const styleSheet = document.createElement('style');\n  styleSheet.id = 'paper-tracker-styles';\n  styleSheet.textContent = styles;\n  document.head.appendChild(styleSheet);\n  \n  logger.debug('Injected styles');\n}\n\n// Add annotation button to link\nfunction injectAnnotationButton(link: HTMLAnchorElement, sourceId: string, paperId: string): void {\n  // Skip if already processed\n  if (link.nextSibling && \n      link.nextSibling.nodeType === Node.ELEMENT_NODE &&\n      (link.nextSibling as Element).classList.contains('paper-annotator')) {\n    return;\n  }\n  \n  // Create annotator button\n  const annotator = document.createElement('span');\n  annotator.className = 'paper-annotator';\n  annotator.textContent = 'ðŸ“';\n  annotator.title = 'Add annotation';\n  \n  // Store data attributes\n  annotator.dataset.sourceId = sourceId;\n  annotator.dataset.paperId = paperId;\n  \n  // Add click handler\n  annotator.addEventListener('click', (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    // Send message to background script to show popup\n    chrome.runtime.sendMessage({\n      type: 'showAnnotationPopup',\n      sourceId,\n      paperId,\n      position: {\n        x: e.clientX,\n        y: e.clientY\n      }\n    });\n  });\n  \n  // Add to page next to link\n  link.parentNode?.insertBefore(annotator, link.nextSibling);\n}\n\n// Get source that can handle a URL\nfunction getSourceForUrl(url: string): SourceIntegration | null {\n  for (const source of sourceIntegrations) {\n    if (source.canHandleUrl(url)) {\n      return source;\n    }\n  }\n  return null;\n}\n\n// Set up click-outside handler for popups\ndocument.addEventListener('click', (e) => {\n  if (activePopup && \n      !activePopup.contains(e.target as Node) && \n      !(e.target as Element).classList.contains('paper-annotator')) {\n    activePopup.parentElement?.remove();\n    activePopup = null;\n  }\n});\n\n// Start session tracking\nfunction startSessionTracking(sourceId: string, paperId: string) {\n  // Stop any existing heartbeat\n  stopHeartbeat();\n  \n  // Only start tracking if tab is visible\n  if (!isTabVisible) {\n    logger.debug(`Not starting session for ${sourceId}:${paperId} because tab is not visible`);\n    return;\n  }\n  \n  // Update current session\n  currentSession = { sourceId, paperId };\n  \n  // Tell background script to start a new session\n  chrome.runtime.sendMessage({\n    type: 'startSession',\n    sourceId,\n    paperId\n  }, response => {\n    if (response?.success) {\n      logger.debug(`Started session for ${sourceId}:${paperId}`);\n      \n      // Start sending heartbeats\n      startHeartbeat();\n    } else {\n      logger.error(`Failed to start session for ${sourceId}:${paperId}`, response?.error);\n    }\n  });\n}\n\n// Start sending heartbeats to background script\nfunction startHeartbeat() {\n  if (!currentSession) return;\n  \n  // Clear any existing interval\n  stopHeartbeat();\n  \n  // Set new interval\n  heartbeatInterval = window.setInterval(() => {\n    if (!currentSession) return;\n    \n    chrome.runtime.sendMessage({\n      type: 'sessionHeartbeat',\n      sourceId: currentSession.sourceId,\n      paperId: currentSession.paperId,\n      timestamp: Date.now()\n    });\n  }, HEARTBEAT_INTERVAL);\n  \n  logger.debug(`Started heartbeat for ${currentSession.sourceId}:${currentSession.paperId}`);\n}\n\n// Stop sending heartbeats\nfunction stopHeartbeat() {\n  if (heartbeatInterval !== null) {\n    clearInterval(heartbeatInterval);\n    heartbeatInterval = null;\n    logger.debug('Stopped heartbeat');\n  }\n}\n\n// End the current session\nfunction endCurrentSession(reason: string) {\n  if (!currentSession) return;\n  \n  const { sourceId, paperId } = currentSession;\n  \n  // Stop heartbeat\n  stopHeartbeat();\n  \n  // Send end session message\n  chrome.runtime.sendMessage({\n    type: 'endSession',\n    sourceId,\n    paperId,\n    reason\n  }, response => {\n    logger.debug(`Ended session for ${sourceId}:${paperId}`, { reason });\n  });\n  \n  // Clear current session\n  currentSession = null;\n}\n\n// Process the current page\nasync function processCurrentPage(force: boolean = false): Promise<PaperMetadata | null> {\n  const url = window.location.href;\n  \n  // Find a source that can handle this URL\n  let source = getSourceForUrl(url);\n  \n  // If no source was found and force parameter is set, use base source\n  if (!source && force) {\n    logger.info(`No matching source found, but force parameter set. Using base source for: ${url}`);\n    source = baseSource;\n  }\n\n  // If we still don't have a source, return null\n  if (!source) {\n    logger.debug(`No source found for URL: ${url}`);\n    return null;\n  }\n\n  // Now that we have a source, extract the paperId\n  const paperId = source.extractPaperId(url);\n  if (!paperId) {\n    logger.info(`Unable to determine a paperId for url: ${url}`);\n    return null;\n  }\n  \n  try {\n    // Use source-specific extraction\n    const metadata = await source.extractMetadata(document, paperId);\n    \n    if (metadata) {\n      // Send metadata to background script\n      chrome.runtime.sendMessage({\n        type: 'paperMetadata',\n        metadata\n      });\n      \n      logger.debug(`Sent extracted metadata to background script for ${metadata.sourceId}:${metadata.paperId}`);\n      \n      // Start session tracking if tab is visible\n      if (isTabVisible) {\n        startSessionTracking(metadata.sourceId, metadata.paperId);\n      }\n      \n      return metadata;\n    }\n  } catch (error) {\n    logger.error(`Error extracting metadata for ${source.id}:${paperId}`, error);\n  }\n  \n  return null;\n}\n\n// Visibility change listener\ndocument.addEventListener('visibilitychange', () => {\n  const wasVisible = isTabVisible;\n  isTabVisible = document.visibilityState === 'visible';\n  \n  if (isTabVisible && !wasVisible) {\n    // Tab has become visible again - restart session\n    logger.info('Tab became visible again');\n    \n    // If we have a current session, restart it\n    if (currentSession) {\n      startSessionTracking(currentSession.sourceId, currentSession.paperId);\n    } else {\n      // Otherwise, try to process the page\n      processCurrentPage();\n    }\n  } else if (!isTabVisible && wasVisible) {\n    // Tab has become hidden - end current session\n    logger.info('Tab hidden');\n    if (currentSession) {\n      endCurrentSession('tab_hidden');\n    }\n  }\n});\n\n// Focus/blur listeners\nwindow.addEventListener('focus', () => {\n  if (!isTabVisible) return; // Don't restart if tab is hidden\n  \n  logger.info('Window gained focus');\n  \n  // If we have a current session, restart it\n  if (currentSession) {\n    startSessionTracking(currentSession.sourceId, currentSession.paperId);\n  } else {\n    // Otherwise, try to process the page\n    processCurrentPage();\n  }\n});\n\nwindow.addEventListener('blur', () => {\n  logger.info('Window lost focus');\n  \n  // End the current session\n  if (currentSession) {\n    endCurrentSession('window_blur');\n  }\n});\n\n// Inform background when page is unloaded\nwindow.addEventListener('beforeunload', () => {\n  if (currentSession) {\n    logger.info('Page unloading');\n    endCurrentSession('page_unload');\n  }\n});\n\n// Message handler for background script\nchrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {\n  logger.debug('Received message', message);\n\n  if (message.type === 'extractPaperMetadata') {\n    logger.debug('Received request to force paper metadata extraction');\n    \n    // Use processCurrentPage with force=true to enable fallback extraction\n    processCurrentPage(true)\n      .then(metadata => {\n        if (metadata) {\n          sendResponse({ success: true, metadata });\n        } else {\n          sendResponse({ success: false, error: 'Failed to extract metadata' });\n        }\n      })\n      .catch(error => {\n        logger.error('Error extracting metadata', error);\n        sendResponse({ \n          success: false, \n          error: error instanceof Error ? error.message : 'Unknown error' \n        });\n      });\n    return true; // Will respond asynchronously\n  }\n  \n  if (message.type === 'showPopup') {\n    // Remove existing popup\n    if (activePopup) {\n      activePopup.parentElement?.remove();\n      activePopup = null;\n    }\n    \n    // Create popup wrapper\n    const wrapper = document.createElement('div');\n    wrapper.className = 'paper-popup-wrapper';\n    \n    // Position near click or element\n    if (message.position) {\n      wrapper.style.left = `${message.position.x}px`;\n      wrapper.style.top = `${message.position.y}px`;\n    }\n    \n    // Create popup\n    const popup = document.createElement('div');\n    popup.className = 'paper-popup';\n    popup.innerHTML = message.html;\n    \n    // Add to page\n    wrapper.appendChild(popup);\n    document.body.appendChild(wrapper);\n    \n    // Set up event handlers\n    if (message.handlers) {\n      for (const handler of message.handlers) {\n        const elements = popup.querySelectorAll(handler.selector);\n        elements.forEach(element => {\n          element.addEventListener(handler.event, () => {\n            chrome.runtime.sendMessage({\n              type: 'popupAction',\n              action: handler.action,\n              sourceId: message.sourceId,\n              paperId: message.paperId,\n              data: {\n                value: element.tagName === 'TEXTAREA' ? \n                  (element as HTMLTextAreaElement).value : \n                  (element as HTMLElement).getAttribute('data-vote'),\n                checked: element.tagName === 'INPUT' ? \n                  (element as HTMLInputElement).checked : undefined,\n                id: (element as HTMLElement).id\n              }\n            });\n          });\n        });\n      }\n    }\n    \n    // Save reference\n    activePopup = popup;\n    \n    sendResponse({ success: true });\n    return true;\n  }\n  \n  if (message.type === 'processPage') {\n    // Re-process the entire page\n    linkProcessor.processLinks(document);\n    processCurrentPage();\n    sendResponse({ success: true });\n    return true;\n  }\n});\n\n// Initialize\n(async function initialize() {\n  // Inject styles\n  injectStyles();\n  \n  // Initialize sources\n  initializeSources();\n  \n  // Process links\n  linkProcessor.processLinks(document);\n  \n  // Start observing for new links\n  linkProcessor.startObserving(document);\n  \n  // Set initial tab visibility\n  isTabVisible = document.visibilityState === 'visible';\n  \n  // Process current page\n  processCurrentPage();\n  \n  // Tell background script we're ready and what page we're on\n  chrome.runtime.sendMessage(\n    { \n      type: 'contentScriptReady', \n      url: window.location.href \n    },\n    (response) => {\n      if (response?.success) {\n        logger.debug('Background script acknowledged ready status');\n      }\n    }\n  );\n})();\n\n// Set up observer for URL changes (single page apps)\nlet lastUrl = location.href;\nnew MutationObserver(() => {\n  const url = location.href;\n  if (url !== lastUrl) {\n    // End any current session\n    if (currentSession) {\n      endCurrentSession('url_change');\n    }\n    \n    // Update URL and process new page\n    lastUrl = url;\n    processCurrentPage();\n  }\n}).observe(document, { subtree: true, childList: true });\n"],"names":["Logger","constructor","module","this","debug","message","data","console","undefined","info","warning","warn","error","loguru","getLogger","logger","SOURCE_TYPES","MetadataExtractor","document","url","location","href","getMetaContent","selector","element","querySelector","getAttribute","extract","metadata","title","extractTitle","authors","extractAuthors","description","extractDescription","publishedDate","extractPublishedDate","doi","extractDoi","journalName","extractJournalName","tags","extractTags","citationAuthors","querySelectorAll","forEach","el","content","push","dcCreators","dcCreator","citationAuthor","ogAuthor","length","join","keywords","split","map","tag","trim","isPdf","toLowerCase","endsWith","getSourceType","generatePaperId","generatePaperIdFromUrl","hash","i","charCodeAt","Math","abs","toString","toUpperCase","substring","BaseSourceIntegration","id","name","urlPatterns","contentScriptMatches","canHandleUrl","some","pattern","test","extractPaperId","createMetadataExtractor","extractMetadata","paperId","extractor","extracted","sourceType","sourceId","abstract","timestamp","Date","toISOString","rating","formatPaperId","parsePaperId","identifier","prefix","startsWith","legacyPrefix","formatObjectId","type","ArxivMetadataExtractor","apiMetadata","super","authorLinks","Array","from","link","textContent","filter","Boolean","replace","datelineElement","dateText","dateMatch","match","subjects","arxivIntegration","API_BASE_URL","fetchFromApi","apiUrl","response","fetch","ok","status","xmlText","text","parser","DOMParser","entry","parseFromString","summary","published","authorElements","journalRef","categoryElements","pageMetadata","hasTitle","hasAuthors","hasAbstract","convertToPageMetadata","enhancedExtractor","mergedMetadata","OpenReviewMetadataExtractor","baseMetadata","find","includes","nextElementSibling","venueElements","venue","keywordsElement","keywordsValue","openReviewIntegration","NatureMetadataExtractor","metaAuthors","natureIntegration","pnasIntegration","miscIntegration","sourceIntegrations","baseSource","activePopup","heartbeatInterval","isTabVisible","currentSession","linkProcessor","onLinkFound","patterns","observer","processedLinks","Set","registerPattern","processLinks","linkId","getLinkId","has","add","startObserving","disconnect","MutationObserver","mutations","newLinks","mutation","addedNodes","node","nodeType","Node","ELEMENT_NODE","tagName","observe","body","childList","subtree","path","getElementPath","current","siblings","parentElement","children","index","indexOf","unshift","stopObserving","nextSibling","classList","contains","annotator","createElement","className","dataset","addEventListener","e","preventDefault","stopPropagation","chrome","runtime","sendMessage","position","x","clientX","y","clientY","parentNode","insertBefore","injectAnnotationButton","startSessionTracking","stopHeartbeat","success","window","setInterval","now","startHeartbeat","clearInterval","endCurrentSession","reason","async","processCurrentPage","force","source","getSourceForUrl","target","remove","wasVisible","visibilityState","onMessage","addListener","sender","sendResponse","then","catch","Error","wrapper","style","left","top","popup","innerHTML","html","appendChild","handlers","handler","event","action","value","checked","getElementById","styleSheet","head","injectStyles","initializeSources","lastUrl"],"mappings":"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"}